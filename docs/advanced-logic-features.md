# ุงูููุฒุงุช ุงูููุทููุฉ ุงููุชูุฏูุฉ ูู ูุบุฉ ุงูุจูุงู
# Advanced Logic Features in Bayan Language

## ๐ ุฌุฏูู ุงููุญุชููุงุช | Table of Contents

1. [ุงูููู ููุดู (Negation as Failure)](#negation-as-failure)
2. [ุนุงูู ุงููุทุน (Cut Operator)](#cut-operator)
3. [ุฌูุน ุงูุญููู (FindAll/BagOf/SetOf)](#collecting-solutions)
4. [ุงูุชุนุฏูู ุงูุฏููุงูููู (Assert/Retract)](#dynamic-modification)
5. [ุงูุชูููู ุงูุญุณุงุจู (Arithmetic Evaluation)](#arithmetic-evaluation)
6. [ูุทุงุจูุฉ ุฃููุงุท ุงูููุงุฆู (List Pattern Matching)](#list-pattern-matching)
7. [ุฃูุซูุฉ ูุชูุฏูุฉ (Advanced Examples)](#advanced-examples)

---

## 1. ุงูููู ููุดู (Negation as Failure) {#negation-as-failure}

### ุงููุตู | Description

ุงูููู ููุดู ูู ุขููุฉ ููุทููุฉ ุชุณูุญ ุจุงูุชุญูู ูู ุนุฏู ุฅููุงููุฉ ุฅุซุจุงุช ูุฏู ูุนูู. ุฅุฐุง ูุดู ุฅุซุจุงุช ุงููุฏูุ ููุนุชุจุฑ ุงูููู ูุงุฌุญุงู.

Negation as failure is a logic mechanism that allows checking if a goal cannot be proven. If proving the goal fails, the negation succeeds.

### ุงูุจููุฉ ุงููุญููุฉ | Syntax

```bayan
// ุงูุนุฑุจูุฉ
ููุณ <ูุฏู>
not <goal>

// ุงูุฅูุฌููุฒูุฉ  
not <goal>
\+ <goal>  // Prolog-style
```

### ุฃูุซูุฉ | Examples

#### ูุซุงู 1: ุงูุชุญูู ูู ุนุฏู ุงูุฒูุงุฌ
```bayan
// ุชุนุฑูู ุงูุญูุงุฆู
ุญูููุฉ ูุชุฒูุฌ("ุฃุญูุฏ");
fact married("Ahmed");

ุญูููุฉ ูุชุฒูุฌ("ุณุงุฑุฉ");
fact married("Sara");

// ุชุนุฑูู ูุงุนุฏุฉ ุงูุฃุนุฒุจ
ูุงุนุฏุฉ ุฃุนุฒุจ(?ุณ) :- ููุณ ูุชุฒูุฌ(?ุณ);
rule single(?x) :- not married(?x);

// ุงุณุชุนูุงูุงุช
ุงุณุชุนูุงู ุฃุนุฒุจ("ูุญูุฏ");  // true - ูุญูุฏ ููุณ ูุชุฒูุฌุงู
query single("Mohamed");  // true - Mohamed is not married

ุงุณุชุนูุงู ุฃุนุฒุจ("ุฃุญูุฏ");   // false - ุฃุญูุฏ ูุชุฒูุฌ
query single("Ahmed");    // false - Ahmed is married
```

#### ูุซุงู 2: ุงูุชุญูู ูู ุนุฏู ูุฌูุฏ ุชุนุงุฑุถ
```bayan
ุญูููุฉ ูุญุฌูุฒ("ูุงุนุฉ_ุฃ", "10:00");
fact booked("room_a", "10:00");

ูุงุนุฏุฉ ูุชุงุญ(?ูุงุนุฉ, ?ููุช) :- ููุณ ูุญุฌูุฒ(?ูุงุนุฉ, ?ููุช);
rule available(?room, ?time) :- not booked(?room, ?time);

ุงุณุชุนูุงู ูุชุงุญ("ูุงุนุฉ_ุฃ", "11:00");  // true
query available("room_a", "11:00");  // true
```

### ุงูุงุณุชุฎุฏุงูุงุช | Use Cases

- โ ุงูุชุญูู ูู ุนุฏู ูุฌูุฏ ุจูุงูุงุช
- โ ุชุทุจูู ุงููููุฏ ุงูุณูุจูุฉ
- โ ุงูุงุณุชุซูุงุกุงุช ูู ุงูููุงุนุฏ
- โ ุงูุชุญูู ูู ุงูุดุฑูุท ุงููุนุงูุณุฉ

---

## 2. ุนุงูู ุงููุทุน (Cut Operator) {#cut-operator}

### ุงููุตู | Description

ุนุงูู ุงููุทุน ูููุน ุงูุชุฑุงุฌุน (backtracking) ุจุนุฏ ููุทุฉ ูุนููุฉ ูู ุงููุงุนุฏุฉุ ููุง ูุญุณู ุงูุฃุฏุงุก ููููุน ุงูุญููู ุบูุฑ ุงููุฑุบูุจุฉ.

The cut operator prevents backtracking after a certain point in a rule, improving performance and preventing unwanted solutions.

### ุงูุจููุฉ ุงููุญููุฉ | Syntax

```bayan
// ุงูุนุฑุจูุฉ
ูุทุน
ุงูุทุน
!

// ุงูุฅูุฌููุฒูุฉ
cut
!
```

### ุฃูุซูุฉ | Examples

#### ูุซุงู 1: ุฅูุฌุงุฏ ุงูุฃูุจุฑ ุจูู ุฑูููู
```bayan
// ูุน ุงููุทุน - ุฃุฏุงุก ุฃูุถู
ูุงุนุฏุฉ ุฃูุจุฑ(?ุณ, ?ุต, ?ุณ) :- ?ุณ >= ?ุต, ูุทุน;
rule max(?x, ?y, ?x) :- ?x >= ?y, cut;

ูุงุนุฏุฉ ุฃูุจุฑ(?ุณ, ?ุต, ?ุต);
rule max(?x, ?y, ?y);

ุงุณุชุนูุงู ุฃูุจุฑ(10, 5, ?ูุชูุฌุฉ);  // ?ูุชูุฌุฉ = 10 (ุญู ูุงุญุฏ ููุท)
query max(10, 5, ?result);       // ?result = 10 (only one solution)
```

#### ูุซุงู 2: ุงูุชุตููู ูุน ุงููุทุน
```bayan
ูุงุนุฏุฉ ุชูุฏูุฑ(?ุฏุฑุฌุฉ, "ููุชุงุฒ") :- ?ุฏุฑุฌุฉ >= 90, ูุทุน;
rule grade(?score, "excellent") :- ?score >= 90, cut;

ูุงุนุฏุฉ ุชูุฏูุฑ(?ุฏุฑุฌุฉ, "ุฌูุฏ_ุฌุฏุงู") :- ?ุฏุฑุฌุฉ >= 80, ูุทุน;
rule grade(?score, "very_good") :- ?score >= 80, cut;

ูุงุนุฏุฉ ุชูุฏูุฑ(?ุฏุฑุฌุฉ, "ุฌูุฏ") :- ?ุฏุฑุฌุฉ >= 70, ูุทุน;
rule grade(?score, "good") :- ?score >= 70, cut;

ูุงุนุฏุฉ ุชูุฏูุฑ(?ุฏุฑุฌุฉ, "ููุจูู");
rule grade(?score, "pass");
```

### ุงูููุงุฆุฏ | Benefits

- โก ุชุญุณูู ุงูุฃุฏุงุก ุจุดูู ูุจูุฑ
- ๐ฏ ููุน ุงูุญููู ุงูููุฑุฑุฉ
- ๐ ุงูุชุญูู ูู ุงูุชุฑุงุฌุน
- ๐ก ููุฏ ุฃูุซุฑ ูุถูุญุงู

---

## 3. ุฌูุน ุงูุญููู (FindAll/BagOf/SetOf) {#collecting-solutions}

### ุงููุตู | Description

ูุฐู ุงูููุฒุงุช ุชุณูุญ ุจุฌูุน ุฌููุน ุงูุญููู ุงูููููุฉ ูุงุณุชุนูุงู ูุนูู ูู ูุงุฆูุฉ ูุงุญุฏุฉ.

These features allow collecting all possible solutions to a query into a single list.

### ุงูุจููุฉ ุงููุญููุฉ | Syntax

```bayan
// FindAll - ุฌูุน ูู ุงูุญููู (ูุน ุงูุชูุฑุงุฑ)
ุงุฌูุน_ูู(<ูุงูุจ>, <ูุฏู>, <ูุชูุฌุฉ>)
findall(<template>, <goal>, <result>)

// BagOf - ุฌูุน ุงูุญููู (ูุน ุงูุชูุฑุงุฑ)
ููุณ_ูู(<ูุงูุจ>, <ูุฏู>, <ูุชูุฌุฉ>)
bagof(<template>, <goal>, <result>)

// SetOf - ุฌูุน ุงูุญููู ุงููุฑูุฏุฉ (ุจุฏูู ุชูุฑุงุฑ)
ูุฌููุนุฉ_ูู(<ูุงูุจ>, <ูุฏู>, <ูุชูุฌุฉ>)
setof(<template>, <goal>, <result>)
```

### ุฃูุซูุฉ | Examples

#### ูุซุงู 1: ุฌูุน ุฃุณูุงุก ุงูุทูุงุจ
```bayan
ุญูููุฉ ุทุงูุจ("ุฃุญูุฏ", "ุญุงุณุจ");
fact student("Ahmed", "CS");

ุญูููุฉ ุทุงูุจ("ุณุงุฑุฉ", "ุญุงุณุจ");
fact student("Sara", "CS");

ุญูููุฉ ุทุงูุจ("ุนูู", "ุฑูุงุถูุงุช");
fact student("Ali", "Math");

// ุฌูุน ูู ุทูุงุจ ุงูุญุงุณุจ
ุฏุน ุทูุงุจ_ุญุงุณุจ = ุงุฌูุน_ูู(?ุณ, ุงุณุชุนูุงู ุทุงูุจ(?ุณ, "ุญุงุณุจ"));
let cs_students = findall(?x, query student(?x, "CS"));

ุงุทุจุน(ุทูุงุจ_ุญุงุณุจ);  // ["ุฃุญูุฏ", "ุณุงุฑุฉ"]
console.log(cs_students);  // ["Ahmed", "Sara"]
```

#### ูุซุงู 2: ุงููุฑู ุจูู BagOf ู SetOf
```bayan
ุญูููุฉ ูุญุจ("ุฃุญูุฏ", "ุจุฑูุฌุฉ");
fact likes("Ahmed", "programming");

ุญูููุฉ ูุญุจ("ุณุงุฑุฉ", "ุจุฑูุฌุฉ");
fact likes("Sara", "programming");

ุญูููุฉ ูุญุจ("ุนูู", "ุจุฑูุฌุฉ");
fact likes("Ali", "programming");

// BagOf - ูุญุชูุธ ุจุงูุชูุฑุงุฑุงุช
ุฏุน ููุณ = ููุณ_ูู(?ููุงูุฉ, ุงุณุชุนูุงู ูุญุจ(?ุดุฎุต, ?ููุงูุฉ));
let bag = bagof(?hobby, query likes(?person, ?hobby));
// ุงููุชูุฌุฉ: ["ุจุฑูุฌุฉ", "ุจุฑูุฌุฉ", "ุจุฑูุฌุฉ"]

// SetOf - ูุฒูู ุงูุชูุฑุงุฑุงุช
ุฏุน ูุฌููุนุฉ = ูุฌููุนุฉ_ูู(?ููุงูุฉ, ุงุณุชุนูุงู ูุญุจ(?ุดุฎุต, ?ููุงูุฉ));
let set = setof(?hobby, query likes(?person, ?hobby));
// ุงููุชูุฌุฉ: ["ุจุฑูุฌุฉ"]
```

### ุงูุงุณุชุฎุฏุงูุงุช | Use Cases

- ๐ ุฌูุน ุงูุจูุงูุงุช ููุชุญููู
- ๐ ุงูุจุญุซ ุนู ุฌููุน ุงูุญููู
- ๐ ุฅูุดุงุก ุงูุชูุงุฑูุฑ
- ๐ฏ ุชุฌููุน ุงููุชุงุฆุฌ

---

## 4. ุงูุชุนุฏูู ุงูุฏููุงูููู (Assert/Retract) {#dynamic-modification}

### ุงููุตู | Description

ุชุณูุญ ูุฐู ุงูููุฒุงุช ุจุฅุถุงูุฉ ูุญุฐู ุงูุญูุงุฆู ูุงูููุงุนุฏ ุฃุซูุงุก ุชูููุฐ ุงูุจุฑูุงูุฌุ ููุง ูุฌุนู ูุงุนุฏุฉ ุงููุนุฑูุฉ ุฏููุงููููุฉ.

These features allow adding and removing facts and rules during program execution, making the knowledge base dynamic.

### ุงูุจููุฉ ุงููุญููุฉ | Syntax

```bayan
// ุฅุถุงูุฉ ุญูููุฉ
ุฃุถู <ุญูููุฉ>
assert <fact>

// ุญุฐู ุญูููุฉ
ุงุญุฐู <ุญูููุฉ>
retract <fact>
```

### ุฃูุซูุฉ | Examples

#### ูุซุงู 1: ุฅุฏุงุฑุฉ ุงูููุธููู
```bayan
// ุฅุถุงูุฉ ููุธู ุฌุฏูุฏ
ุฃุถู ููุธู("ูุญูุฏ", "ูููุฏุณ");
assert employee("Mohamed", "engineer");

// ุงูุชุญูู ูู ูุฌูุฏู
ุงุณุชุนูุงู ููุธู("ูุญูุฏ", ?ูุธููุฉ);  // ?ูุธููุฉ = "ูููุฏุณ"
query employee("Mohamed", ?job);   // ?job = "engineer"

// ุญุฐู ุงูููุธู
ุงุญุฐู ููุธู("ูุญูุฏ", "ูููุฏุณ");
retract employee("Mohamed", "engineer");

// ุงูุชุญูู ูู ุนุฏู ูุฌูุฏู
ุงุณุชุนูุงู ููุธู("ูุญูุฏ", ?ูุธููุฉ);  // false
query employee("Mohamed", ?job);   // false
```

#### ูุซุงู 2: ูุธุงู ุงูุญุฌูุฒุงุช
```bayan
ุฏุงูุฉ ุงุญุฌุฒ_ูุงุนุฉ(ูุงุนุฉ: ูุต, ููุช: ูุต): ููุทูู {
  // ุงูุชุญูู ูู ุงูุชููุฑ
  ุฅุฐุง (ููุณ ุงุณุชุนูุงู ูุญุฌูุฒ(ูุงุนุฉ, ููุช)) {
    // ุฅุถุงูุฉ ุงูุญุฌุฒ
    ุฃุถู ูุญุฌูุฒ(ูุงุนุฉ, ููุช);
    ุฃุฑุฌุน ุตุญูุญ;
  }
  ุฃุฑุฌุน ุฎุทุฃ;
}

function bookRoom(room: string, time: string): boolean {
  if (not query booked(room, time)) {
    assert booked(room, time);
    return true;
  }
  return false;
}

ุฏุงูุฉ ุฃูุบ_ุญุฌุฒ(ูุงุนุฉ: ูุต, ููุช: ูุต): ููุทูู {
  ุฃุฑุฌุน ุงุญุฐู ูุญุฌูุฒ(ูุงุนุฉ, ููุช);
}

function cancelBooking(room: string, time: string): boolean {
  return retract booked(room, time);
}
```

### ุงูุงุณุชุฎุฏุงูุงุช | Use Cases

- ๐ ููุงุนุฏ ุงููุนุฑูุฉ ุงูุฏููุงููููุฉ
- ๐พ ุฃูุธูุฉ ููุงุนุฏ ุงูุจูุงูุงุช
- ๐ฎ ุงูุฃูุนุงุจ ูุงููุญุงูุงุฉ
- ๐ค ุฃูุธูุฉ ุงูุฐูุงุก ุงูุงุตุทูุงุนู

---

## 5. ุงูุชูููู ุงูุญุณุงุจู (Arithmetic Evaluation) {#arithmetic-evaluation}

### ุงููุตู | Description

ุชุณูุญ ุจุชูููู ุงูุชุนุจูุฑุงุช ุงูุญุณุงุจูุฉ ูู ุงูุณูุงู ุงูููุทูู ูุฅุฌุฑุงุก ุงูููุงุฑูุงุช ุงูุฑูุงุถูุฉ.

Allows evaluating arithmetic expressions in logic context and performing mathematical comparisons.

### ุงูุจููุฉ ุงููุญููุฉ | Syntax

```bayan
// ุงูุชูููู ุงูุญุณุงุจู
?ูุชุบูุฑ ูู <ุชุนุจูุฑ>
?variable is <expression>

// ุงูููุงุฑูุงุช
?ุณ > ?ุต   // ุฃูุจุฑ ูู | greater than
?ุณ < ?ุต   // ุฃุตุบุฑ ูู | less than
?ุณ >= ?ุต  // ุฃูุจุฑ ูู ุฃู ูุณุงูู | greater than or equal
?ุณ <= ?ุต  // ุฃุตุบุฑ ูู ุฃู ูุณุงูู | less than or equal
?ุณ === ?ุต // ูุณุงูู | equal
?ุณ !== ?ุต // ูุง ูุณุงูู | not equal
```

### ุฃูุซูุฉ | Examples

#### ูุซุงู 1: ุญุณุงุจ ุงููุถุฑูุจ (Factorial)
```bayan
ูุงุนุฏุฉ ูุถุฑูุจ(0, 1) :- ูุทุน;
rule factorial(0, 1) :- cut;

ูุงุนุฏุฉ ูุถุฑูุจ(?ู, ?ูุชูุฌุฉ) :-
  ?ู > 0,
  ?ู1 ูู ?ู - 1,
  ุงุณุชุนูุงู ูุถุฑูุจ(?ู1, ?ูุชูุฌุฉ1),
  ?ูุชูุฌุฉ ูู ?ู * ?ูุชูุฌุฉ1;

rule factorial(?n, ?result) :-
  ?n > 0,
  ?n1 is ?n - 1,
  query factorial(?n1, ?result1),
  ?result is ?n * ?result1;

ุงุณุชุนูุงู ูุถุฑูุจ(5, ?ูุชูุฌุฉ);  // ?ูุชูุฌุฉ = 120
query factorial(5, ?result);   // ?result = 120
```

#### ูุซุงู 2: ูุชุชุงููุฉ ููุจููุงุชุดู
```bayan
ูุงุนุฏุฉ ููุจููุงุชุดู(0, 0) :- ูุทุน;
rule fibonacci(0, 0) :- cut;

ูุงุนุฏุฉ ููุจููุงุชุดู(1, 1) :- ูุทุน;
rule fibonacci(1, 1) :- cut;

ูุงุนุฏุฉ ููุจููุงุชุดู(?ู, ?ูุชูุฌุฉ) :-
  ?ู > 1,
  ?ู1 ูู ?ู - 1,
  ?ู2 ูู ?ู - 2,
  ุงุณุชุนูุงู ููุจููุงุชุดู(?ู1, ?ู1),
  ุงุณุชุนูุงู ููุจููุงุชุดู(?ู2, ?ู2),
  ?ูุชูุฌุฉ ูู ?ู1 + ?ู2;

rule fibonacci(?n, ?result) :-
  ?n > 1,
  ?n1 is ?n - 1,
  ?n2 is ?n - 2,
  query fibonacci(?n1, ?f1),
  query fibonacci(?n2, ?f2),
  ?result is ?f1 + ?f2;
```

---

## 6. ูุทุงุจูุฉ ุฃููุงุท ุงูููุงุฆู (List Pattern Matching) {#list-pattern-matching}

### ุงููุตู | Description

ุชุณูุญ ุจูุทุงุจูุฉ ุฃููุงุท ุงูููุงุฆู ุจุงุณุชุฎุฏุงู ุจููุฉ [Head|Tail] ุงููุดุงุจูุฉ ูู Prolog.

Allows list pattern matching using [Head|Tail] syntax similar to Prolog.

### ุงูุจููุฉ ุงููุญููุฉ | Syntax

```bayan
[<ุฑุฃุณ>|<ุฐูู>]
[<head>|<tail>]
```

### ุฃูุซูุฉ | Examples

```bayan
// ูุทุงุจูุฉ ุฃูู ุนูุตุฑ
ูุงุนุฏุฉ ุฃูู([?ุฑุฃุณ|?ุฐูู], ?ุฑุฃุณ);
rule first([?head|?tail], ?head);

// ุทูู ุงููุงุฆูุฉ
ูุงุนุฏุฉ ุทูู_ูุงุฆูุฉ([], 0) :- ูุทุน;
rule list_length([], 0) :- cut;

ูุงุนุฏุฉ ุทูู_ูุงุฆูุฉ([?ุฑุฃุณ|?ุฐูู], ?ุทูู) :-
  ุงุณุชุนูุงู ุทูู_ูุงุฆูุฉ(?ุฐูู, ?ุทูู_ุฐูู),
  ?ุทูู ูู ?ุทูู_ุฐูู + 1;

rule list_length([?head|?tail], ?length) :-
  query list_length(?tail, ?tail_length),
  ?length is ?tail_length + 1;
```

---

## 7. ุฃูุซูุฉ ูุชูุฏูุฉ (Advanced Examples) {#advanced-examples}

### ูุธุงู ุฎุจูุฑ ููุชุดุฎูุต ุงูุทุจู

ุฑุงุฌุน ููู `examples/advanced-logic.bn` ููุงุทูุงุน ุนูู ูุซุงู ูุงูู ููุธุงู ุฎุจูุฑ ููุชุดุฎูุต ุงูุทุจู ูุณุชุฎุฏู ุฌููุน ุงูููุฒุงุช ุงููุชูุฏูุฉ.

See `examples/advanced-logic.bn` for a complete medical diagnosis expert system example using all advanced features.

### ูุธุงู ุฅุฏุงุฑุฉ ุทูุงุจ ูุชูุงูู

ุฑุงุฌุน ููู `examples/bilingual-advanced-logic.bn` ููุซุงู ูุฌูุน ุจูู ุงูุจุฑูุฌุฉ ุงูููุทููุฉ ูุงูุฅุฌุฑุงุฆูุฉ ูุงููุงุฆููุฉ.

See `examples/bilingual-advanced-logic.bn` for an example combining logic, procedural, and object-oriented programming.

---

## ๐ฏ ุงูุฎูุงุตุฉ | Summary

ูุบุฉ ุงูุจูุงู ุชููุฑ ููุฒุงุช ููุทููุฉ ูุชูุฏูุฉ ุชููู Prolog ูู ุนุฏุฉ ุฌูุงูุจ:

Bayan provides advanced logic features that surpass Prolog in several aspects:

โ **ุงูููู ููุดู** - ููุชุญูู ูู ุนุฏู ุฅููุงููุฉ ุงูุฅุซุจุงุช  
โ **ุนุงูู ุงููุทุน** - ูุชุญุณูู ุงูุฃุฏุงุก ูููุน ุงูุชุฑุงุฌุน  
โ **ุฌูุน ุงูุญููู** - FindAll, BagOf, SetOf  
โ **ุงูุชุนุฏูู ุงูุฏููุงูููู** - Assert/Retract  
โ **ุงูุชูููู ุงูุญุณุงุจู** - ุนูููุงุช ุญุณุงุจูุฉ ูุชูุฏูุฉ  
โ **ูุทุงุจูุฉ ุงูููุงุฆู** - [Head|Tail] pattern matching  
โ **ุซูุงุฆูุฉ ุงููุบุฉ** - ุฏุนู ุงูุนุฑุจูุฉ ูุงูุฅูุฌููุฒูุฉ ูุนุงู  
โ **ุงูุชูุงูู ุงููุฌูู** - ุฏูุฌ OOP ูุงูุจุฑูุฌุฉ ุงูุฅุฌุฑุงุฆูุฉ ูุงูููุทููุฉ

---

## ๐ ูุฑุงุฌุน ุฅุถุงููุฉ | Additional References

- [ุฏููู ุงูุจุฑูุฌุฉ ุงูููุทููุฉ](./logic-programming-guide.md)
- [ุฃูุซูุฉ ูุชูุฏูุฉ](../examples/advanced-logic.bn)
- [ุฏููู API](./api-reference.md)

