// 🎮 Space Shooter Game - لعبة حرب الفضاء
// Complete game built with Bayan - لعبة كاملة مبنية بلغة البيان
// Demonstrates: OOP, Event Handling, Collision Detection, Game Loop
// يوضح: البرمجة الكائنية، معالجة الأحداث، كشف التصادم، حلقة اللعبة

// ============================================
// English Version - النسخة الإنجليزية
// ============================================

// Player Spaceship Class
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 50;
        this.height = 50;
        this.speed = 5;
        this.health = 100;
        this.maxHealth = 100;
        this.bullets = [];
        this.score = 0;
        this.color = '#00ff00';
    }
    
    moveLeft() {
        if (this.x > 0) {
            this.x -= this.speed;
        }
    }
    
    moveRight(canvasWidth) {
        if (this.x + this.width < canvasWidth) {
            this.x += this.speed;
        }
    }
    
    moveUp() {
        if (this.y > 0) {
            this.y -= this.speed;
        }
    }
    
    moveDown(canvasHeight) {
        if (this.y + this.height < canvasHeight) {
            this.y += this.speed;
        }
    }
    
    shoot() {
        const bullet = new Bullet(
            this.x + this.width / 2 - 2,
            this.y,
            -10,
            '#00ff00'
        );
        this.bullets.push(bullet);
    }
    
    update(canvasHeight) {
        // Update bullets
        this.bullets = this.bullets.filter(bullet => {
            bullet.update();
            return bullet.y > 0;
        });
    }
    
    draw(ctx) {
        // Draw spaceship
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.x + this.width / 2, this.y);
        ctx.lineTo(this.x, this.y + this.height);
        ctx.lineTo(this.x + this.width, this.y + this.height);
        ctx.closePath();
        ctx.fill();
        
        // Draw engine glow
        ctx.fillStyle = '#ff6600';
        ctx.fillRect(this.x + 10, this.y + this.height, 10, 5);
        ctx.fillRect(this.x + 30, this.y + this.height, 10, 5);
        
        // Draw bullets
        for (let bullet of this.bullets) {
            bullet.draw(ctx);
        }
        
        // Draw health bar
        this.drawHealthBar(ctx);
    }
    
    drawHealthBar(ctx) {
        const barWidth = 50;
        const barHeight = 5;
        const barX = this.x;
        const barY = this.y - 10;
        
        // Background
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Health
        const healthWidth = (this.health / this.maxHealth) * barWidth;
        ctx.fillStyle = this.health > 50 ? '#00ff00' : '#ff0000';
        ctx.fillRect(barX, barY, healthWidth, barHeight);
    }
    
    takeDamage(amount) {
        this.health -= amount;
        if (this.health < 0) this.health = 0;
    }
    
    isAlive() {
        return this.health > 0;
    }
}

// Enemy Class
class Enemy {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 40;
        this.speed = 2 + Math.random() * 2;
        this.health = type === 'boss' ? 50 : 10;
        this.maxHealth = this.health;
        this.type = type;
        this.color = type === 'boss' ? '#ff0000' : '#ff6b6b';
        this.bullets = [];
        this.shootTimer = 0;
        this.shootInterval = 60 + Math.random() * 60;
    }
    
    update(canvasHeight) {
        this.y += this.speed;
        
        // Shoot bullets
        this.shootTimer++;
        if (this.shootTimer > this.shootInterval) {
            this.shoot();
            this.shootTimer = 0;
        }
        
        // Update bullets
        this.bullets = this.bullets.filter(bullet => {
            bullet.update();
            return bullet.y < canvasHeight;
        });
    }
    
    shoot() {
        const bullet = new Bullet(
            this.x + this.width / 2 - 2,
            this.y + this.height,
            5,
            '#ff0000'
        );
        this.bullets.push(bullet);
    }
    
    draw(ctx) {
        // Draw enemy
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw eyes
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x + 10, this.y + 10, 8, 8);
        ctx.fillRect(this.x + 22, this.y + 10, 8, 8);
        
        // Draw bullets
        for (let bullet of this.bullets) {
            bullet.draw(ctx);
        }
        
        // Draw health bar for boss
        if (this.type === 'boss') {
            this.drawHealthBar(ctx);
        }
    }
    
    drawHealthBar(ctx) {
        const barWidth = 40;
        const barHeight = 4;
        const barX = this.x;
        const barY = this.y - 8;
        
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        const healthWidth = (this.health / this.maxHealth) * barWidth;
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(barX, barY, healthWidth, barHeight);
    }
    
    takeDamage(amount) {
        this.health -= amount;
        return this.health <= 0;
    }
}

// Bullet Class
class Bullet {
    constructor(x, y, speedY, color) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 10;
        this.speedY = speedY;
        this.color = color;
    }
    
    update() {
        this.y += this.speedY;
    }
    
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Glow effect
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
    }
}

// Particle Effect Class
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.size = Math.random() * 4 + 2;
        this.color = color;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        return this.life > 0;
    }
    
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

// Star Background Class
class Star {
    constructor(x, y, speed) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.size = Math.random() * 2 + 1;
    }
    
    update(canvasHeight) {
        this.y += this.speed;
        if (this.y > canvasHeight) {
            this.y = 0;
            this.x = Math.random() * 800;
        }
    }
    
    draw(ctx) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

// Game Manager Class
class Game {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = 800;
        this.canvas.height = 600;
        
        this.player = new Player(375, 500);
        this.enemies = [];
        this.particles = [];
        this.stars = [];
        
        this.keys = {};
        this.gameOver = false;
        this.paused = false;
        this.wave = 1;
        this.enemySpawnTimer = 0;
        this.enemySpawnInterval = 120;
        
        this.initStars();
        this.setupControls();
        this.animate();
    }
    
    initStars() {
        for (let i = 0; i < 100; i++) {
            this.stars.push(new Star(
                Math.random() * 800,
                Math.random() * 600,
                Math.random() * 2 + 0.5
            ));
        }
    }
    
    setupControls() {
        window.addEventListener('keydown', (e) => {
            this.keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault();
                if (!this.gameOver && !this.paused) {
                    this.player.shoot();
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            this.keys[e.key] = false;
        });
    }
    
    spawnEnemy() {
        const x = Math.random() * (800 - 40);
        const type = Math.random() > 0.9 ? 'boss' : 'normal';
        this.enemies.push(new Enemy(x, -40, type));
    }
    
    createExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }
    
    checkCollisions() {
        // Player bullets vs enemies
        for (let enemy of this.enemies) {
            for (let bullet of this.player.bullets) {
                if (this.collision(bullet, enemy)) {
                    if (enemy.takeDamage(10)) {
                        this.createExplosion(enemy.x + 20, enemy.y + 20, '#ff6b6b');
                        this.enemies = this.enemies.filter(e => e !== enemy);
                        this.player.score += enemy.type === 'boss' ? 100 : 10;
                    }
                    this.player.bullets = this.player.bullets.filter(b => b !== bullet);
                }
            }
        }
        
        // Enemy bullets vs player
        for (let enemy of this.enemies) {
            for (let bullet of enemy.bullets) {
                if (this.collision(bullet, this.player)) {
                    this.player.takeDamage(5);
                    enemy.bullets = enemy.bullets.filter(b => b !== bullet);
                    this.createExplosion(this.player.x + 25, this.player.y + 25, '#00ff00');
                }
            }
        }
        
        // Enemies vs player
        for (let enemy of this.enemies) {
            if (this.collision(enemy, this.player)) {
                this.player.takeDamage(20);
                this.createExplosion(enemy.x + 20, enemy.y + 20, '#ff6b6b');
                this.enemies = this.enemies.filter(e => e !== enemy);
            }
        }
    }
    
    collision(obj1, obj2) {
        return obj1.x < obj2.x + obj2.width &&
               obj1.x + obj1.width > obj2.x &&
               obj1.y < obj2.y + obj2.height &&
               obj1.y + obj1.height > obj2.y;
    }
    
    update() {
        if (this.gameOver || this.paused) return;
        
        // Update stars
        for (let star of this.stars) {
            star.update(600);
        }
        
        // Player movement
        if (this.keys['ArrowLeft'] || this.keys['a']) this.player.moveLeft();
        if (this.keys['ArrowRight'] || this.keys['d']) this.player.moveRight(800);
        if (this.keys['ArrowUp'] || this.keys['w']) this.player.moveUp();
        if (this.keys['ArrowDown'] || this.keys['s']) this.player.moveDown(600);
        
        // Update player
        this.player.update(600);
        
        // Spawn enemies
        this.enemySpawnTimer++;
        if (this.enemySpawnTimer > this.enemySpawnInterval) {
            this.spawnEnemy();
            this.enemySpawnTimer = 0;
        }
        
        // Update enemies
        this.enemies = this.enemies.filter(enemy => {
            enemy.update(600);
            return enemy.y < 650;
        });
        
        // Update particles
        this.particles = this.particles.filter(p => p.update());
        
        // Check collisions
        this.checkCollisions();
        
        // Check game over
        if (!this.player.isAlive()) {
            this.gameOver = true;
        }
    }
    
    draw() {
        // Clear canvas
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, 800, 600);
        
        // Draw stars
        for (let star of this.stars) {
            star.draw(this.ctx);
        }
        
        // Draw particles
        for (let particle of this.particles) {
            particle.draw(this.ctx);
        }
        
        // Draw player
        if (this.player.isAlive()) {
            this.player.draw(this.ctx);
        }
        
        // Draw enemies
        for (let enemy of this.enemies) {
            enemy.draw(this.ctx);
        }
        
        // Draw UI
        this.drawUI();
        
        // Draw game over
        if (this.gameOver) {
            this.drawGameOver();
        }
    }
    
    drawUI() {
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '20px Arial';
        this.ctx.fillText(`Score: ${this.player.score}`, 10, 30);
        this.ctx.fillText(`Health: ${this.player.health}`, 10, 60);
        this.ctx.fillText(`Wave: ${this.wave}`, 10, 90);
    }
    
    drawGameOver() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(0, 0, 800, 600);
        
        this.ctx.fillStyle = '#ff0000';
        this.ctx.font = '60px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', 400, 250);
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '30px Arial';
        this.ctx.fillText(`Final Score: ${this.player.score}`, 400, 320);
        this.ctx.fillText('Press R to Restart', 400, 370);
        
        this.ctx.textAlign = 'left';
    }
    
    animate() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.animate());
    }
    
    restart() {
        this.player = new Player(375, 500);
        this.enemies = [];
        this.particles = [];
        this.gameOver = false;
        this.wave = 1;
    }
}

// Initialize game
const game = new Game('gameCanvas');

// Restart on R key
window.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
        game.restart();
    }
});

// ============================================
// Arabic Version - النسخة العربية
// ============================================

// صنف اللاعب
صنف لاعب {
    منشئ(س, ص) {
        هذا.س = س;
        هذا.ص = ص;
        هذا.العرض = 50;
        هذا.الارتفاع = 50;
        هذا.السرعة = 5;
        هذا.الصحة = 100;
        هذا.الصحة_القصوى = 100;
        هذا.الرصاصات = [];
        هذا.النقاط = 0;
        هذا.اللون = '#00ff00';
    }

    دالة تحرك_يسار() {
        اذا (هذا.س > 0) {
            هذا.س = هذا.س - هذا.السرعة;
        }
    }

    دالة تحرك_يمين(عرض_اللوحة) {
        اذا (هذا.س + هذا.العرض < عرض_اللوحة) {
            هذا.س = هذا.س + هذا.السرعة;
        }
    }

    دالة اطلق() {
        const رصاصة = جديد رصاصة(
            هذا.س + هذا.العرض / 2 - 2,
            هذا.ص,
            -10,
            '#00ff00'
        );
        هذا.الرصاصات.push(رصاصة);
    }

    دالة حدث(ارتفاع_اللوحة) {
        هذا.الرصاصات = هذا.الرصاصات.filter(رصاصة => {
            رصاصة.حدث();
            ارجع رصاصة.ص > 0;
        });
    }

    دالة ارسم(السياق) {
        السياق.fillStyle = هذا.اللون;
        السياق.beginPath();
        السياق.moveTo(هذا.س + هذا.العرض / 2, هذا.ص);
        السياق.lineTo(هذا.س, هذا.ص + هذا.الارتفاع);
        السياق.lineTo(هذا.س + هذا.العرض, هذا.ص + هذا.الارتفاع);
        السياق.closePath();
        السياق.fill();

        لكل (let رصاصة of هذا.الرصاصات) {
            رصاصة.ارسم(السياق);
        }
    }

    دالة خذ_ضرر(المقدار) {
        هذا.الصحة = هذا.الصحة - المقدار;
        اذا (هذا.الصحة < 0) هذا.الصحة = 0;
    }

    دالة حي() {
        ارجع هذا.الصحة > 0;
    }
}

// صنف العدو
صنف عدو {
    منشئ(س, ص, النوع) {
        هذا.س = س;
        هذا.ص = ص;
        هذا.العرض = 40;
        هذا.الارتفاع = 40;
        هذا.السرعة = 2 + Math.random() * 2;
        هذا.الصحة = النوع === 'boss' ? 50 : 10;
        هذا.النوع = النوع;
        هذا.اللون = النوع === 'boss' ? '#ff0000' : '#ff6b6b';
        هذا.الرصاصات = [];
    }

    دالة حدث(ارتفاع_اللوحة) {
        هذا.ص = هذا.ص + هذا.السرعة;

        هذا.الرصاصات = هذا.الرصاصات.filter(رصاصة => {
            رصاصة.حدث();
            ارجع رصاصة.ص < ارتفاع_اللوحة;
        });
    }

    دالة ارسم(السياق) {
        السياق.fillStyle = هذا.اللون;
        السياق.fillRect(هذا.س, هذا.ص, هذا.العرض, هذا.الارتفاع);

        لكل (let رصاصة of هذا.الرصاصات) {
            رصاصة.ارسم(السياق);
        }
    }

    دالة خذ_ضرر(المقدار) {
        هذا.الصحة = هذا.الصحة - المقدار;
        ارجع هذا.الصحة <= 0;
    }
}

// صنف الرصاصة
صنف رصاصة {
    منشئ(س, ص, سرعة_ص, اللون) {
        هذا.س = س;
        هذا.ص = ص;
        هذا.العرض = 4;
        هذا.الارتفاع = 10;
        هذا.سرعة_ص = سرعة_ص;
        هذا.اللون = اللون;
    }

    دالة حدث() {
        هذا.ص = هذا.ص + هذا.سرعة_ص;
    }

    دالة ارسم(السياق) {
        السياق.fillStyle = هذا.اللون;
        السياق.fillRect(هذا.س, هذا.ص, هذا.العرض, هذا.الارتفاع);
    }
}

