// ๐ฎ Space Shooter Game - ูุนุจุฉ ุญุฑุจ ุงููุถุงุก
// Complete game built with Bayan - ูุนุจุฉ ูุงููุฉ ูุจููุฉ ุจูุบุฉ ุงูุจูุงู
// Demonstrates: OOP, Event Handling, Collision Detection, Game Loop
// ููุถุญ: ุงูุจุฑูุฌุฉ ุงููุงุฆููุฉุ ูุนุงูุฌุฉ ุงูุฃุญุฏุงุซุ ูุดู ุงูุชุตุงุฏูุ ุญููุฉ ุงููุนุจุฉ

// ============================================
// English Version - ุงููุณุฎุฉ ุงูุฅูุฌููุฒูุฉ
// ============================================

// Player Spaceship Class
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 50;
        this.height = 50;
        this.speed = 5;
        this.health = 100;
        this.maxHealth = 100;
        this.bullets = [];
        this.score = 0;
        this.color = '#00ff00';
    }
    
    moveLeft() {
        if (this.x > 0) {
            this.x -= this.speed;
        }
    }
    
    moveRight(canvasWidth) {
        if (this.x + this.width < canvasWidth) {
            this.x += this.speed;
        }
    }
    
    moveUp() {
        if (this.y > 0) {
            this.y -= this.speed;
        }
    }
    
    moveDown(canvasHeight) {
        if (this.y + this.height < canvasHeight) {
            this.y += this.speed;
        }
    }
    
    shoot() {
        const bullet = new Bullet(
            this.x + this.width / 2 - 2,
            this.y,
            -10,
            '#00ff00'
        );
        this.bullets.push(bullet);
    }
    
    update(canvasHeight) {
        // Update bullets
        this.bullets = this.bullets.filter(bullet => {
            bullet.update();
            return bullet.y > 0;
        });
    }
    
    draw(ctx) {
        // Draw spaceship
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.moveTo(this.x + this.width / 2, this.y);
        ctx.lineTo(this.x, this.y + this.height);
        ctx.lineTo(this.x + this.width, this.y + this.height);
        ctx.closePath();
        ctx.fill();
        
        // Draw engine glow
        ctx.fillStyle = '#ff6600';
        ctx.fillRect(this.x + 10, this.y + this.height, 10, 5);
        ctx.fillRect(this.x + 30, this.y + this.height, 10, 5);
        
        // Draw bullets
        for (let bullet of this.bullets) {
            bullet.draw(ctx);
        }
        
        // Draw health bar
        this.drawHealthBar(ctx);
    }
    
    drawHealthBar(ctx) {
        const barWidth = 50;
        const barHeight = 5;
        const barX = this.x;
        const barY = this.y - 10;
        
        // Background
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Health
        const healthWidth = (this.health / this.maxHealth) * barWidth;
        ctx.fillStyle = this.health > 50 ? '#00ff00' : '#ff0000';
        ctx.fillRect(barX, barY, healthWidth, barHeight);
    }
    
    takeDamage(amount) {
        this.health -= amount;
        if (this.health < 0) this.health = 0;
    }
    
    isAlive() {
        return this.health > 0;
    }
}

// Enemy Class
class Enemy {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.width = 40;
        this.height = 40;
        this.speed = 2 + Math.random() * 2;
        this.health = type === 'boss' ? 50 : 10;
        this.maxHealth = this.health;
        this.type = type;
        this.color = type === 'boss' ? '#ff0000' : '#ff6b6b';
        this.bullets = [];
        this.shootTimer = 0;
        this.shootInterval = 60 + Math.random() * 60;
    }
    
    update(canvasHeight) {
        this.y += this.speed;
        
        // Shoot bullets
        this.shootTimer++;
        if (this.shootTimer > this.shootInterval) {
            this.shoot();
            this.shootTimer = 0;
        }
        
        // Update bullets
        this.bullets = this.bullets.filter(bullet => {
            bullet.update();
            return bullet.y < canvasHeight;
        });
    }
    
    shoot() {
        const bullet = new Bullet(
            this.x + this.width / 2 - 2,
            this.y + this.height,
            5,
            '#ff0000'
        );
        this.bullets.push(bullet);
    }
    
    draw(ctx) {
        // Draw enemy
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Draw eyes
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x + 10, this.y + 10, 8, 8);
        ctx.fillRect(this.x + 22, this.y + 10, 8, 8);
        
        // Draw bullets
        for (let bullet of this.bullets) {
            bullet.draw(ctx);
        }
        
        // Draw health bar for boss
        if (this.type === 'boss') {
            this.drawHealthBar(ctx);
        }
    }
    
    drawHealthBar(ctx) {
        const barWidth = 40;
        const barHeight = 4;
        const barX = this.x;
        const barY = this.y - 8;
        
        ctx.fillStyle = '#333';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        const healthWidth = (this.health / this.maxHealth) * barWidth;
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(barX, barY, healthWidth, barHeight);
    }
    
    takeDamage(amount) {
        this.health -= amount;
        return this.health <= 0;
    }
}

// Bullet Class
class Bullet {
    constructor(x, y, speedY, color) {
        this.x = x;
        this.y = y;
        this.width = 4;
        this.height = 10;
        this.speedY = speedY;
        this.color = color;
    }
    
    update() {
        this.y += this.speedY;
    }
    
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Glow effect
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
    }
}

// Particle Effect Class
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
        this.size = Math.random() * 4 + 2;
        this.color = color;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        return this.life > 0;
    }
    
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

// Star Background Class
class Star {
    constructor(x, y, speed) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.size = Math.random() * 2 + 1;
    }
    
    update(canvasHeight) {
        this.y += this.speed;
        if (this.y > canvasHeight) {
            this.y = 0;
            this.x = Math.random() * 800;
        }
    }
    
    draw(ctx) {
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

// Game Manager Class
class Game {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = 800;
        this.canvas.height = 600;
        
        this.player = new Player(375, 500);
        this.enemies = [];
        this.particles = [];
        this.stars = [];
        
        this.keys = {};
        this.gameOver = false;
        this.paused = false;
        this.wave = 1;
        this.enemySpawnTimer = 0;
        this.enemySpawnInterval = 120;
        
        this.initStars();
        this.setupControls();
        this.animate();
    }
    
    initStars() {
        for (let i = 0; i < 100; i++) {
            this.stars.push(new Star(
                Math.random() * 800,
                Math.random() * 600,
                Math.random() * 2 + 0.5
            ));
        }
    }
    
    setupControls() {
        window.addEventListener('keydown', (e) => {
            this.keys[e.key] = true;
            if (e.key === ' ') {
                e.preventDefault();
                if (!this.gameOver && !this.paused) {
                    this.player.shoot();
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            this.keys[e.key] = false;
        });
    }
    
    spawnEnemy() {
        const x = Math.random() * (800 - 40);
        const type = Math.random() > 0.9 ? 'boss' : 'normal';
        this.enemies.push(new Enemy(x, -40, type));
    }
    
    createExplosion(x, y, color) {
        for (let i = 0; i < 20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }
    
    checkCollisions() {
        // Player bullets vs enemies
        for (let enemy of this.enemies) {
            for (let bullet of this.player.bullets) {
                if (this.collision(bullet, enemy)) {
                    if (enemy.takeDamage(10)) {
                        this.createExplosion(enemy.x + 20, enemy.y + 20, '#ff6b6b');
                        this.enemies = this.enemies.filter(e => e !== enemy);
                        this.player.score += enemy.type === 'boss' ? 100 : 10;
                    }
                    this.player.bullets = this.player.bullets.filter(b => b !== bullet);
                }
            }
        }
        
        // Enemy bullets vs player
        for (let enemy of this.enemies) {
            for (let bullet of enemy.bullets) {
                if (this.collision(bullet, this.player)) {
                    this.player.takeDamage(5);
                    enemy.bullets = enemy.bullets.filter(b => b !== bullet);
                    this.createExplosion(this.player.x + 25, this.player.y + 25, '#00ff00');
                }
            }
        }
        
        // Enemies vs player
        for (let enemy of this.enemies) {
            if (this.collision(enemy, this.player)) {
                this.player.takeDamage(20);
                this.createExplosion(enemy.x + 20, enemy.y + 20, '#ff6b6b');
                this.enemies = this.enemies.filter(e => e !== enemy);
            }
        }
    }
    
    collision(obj1, obj2) {
        return obj1.x < obj2.x + obj2.width &&
               obj1.x + obj1.width > obj2.x &&
               obj1.y < obj2.y + obj2.height &&
               obj1.y + obj1.height > obj2.y;
    }
    
    update() {
        if (this.gameOver || this.paused) return;
        
        // Update stars
        for (let star of this.stars) {
            star.update(600);
        }
        
        // Player movement
        if (this.keys['ArrowLeft'] || this.keys['a']) this.player.moveLeft();
        if (this.keys['ArrowRight'] || this.keys['d']) this.player.moveRight(800);
        if (this.keys['ArrowUp'] || this.keys['w']) this.player.moveUp();
        if (this.keys['ArrowDown'] || this.keys['s']) this.player.moveDown(600);
        
        // Update player
        this.player.update(600);
        
        // Spawn enemies
        this.enemySpawnTimer++;
        if (this.enemySpawnTimer > this.enemySpawnInterval) {
            this.spawnEnemy();
            this.enemySpawnTimer = 0;
        }
        
        // Update enemies
        this.enemies = this.enemies.filter(enemy => {
            enemy.update(600);
            return enemy.y < 650;
        });
        
        // Update particles
        this.particles = this.particles.filter(p => p.update());
        
        // Check collisions
        this.checkCollisions();
        
        // Check game over
        if (!this.player.isAlive()) {
            this.gameOver = true;
        }
    }
    
    draw() {
        // Clear canvas
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, 800, 600);
        
        // Draw stars
        for (let star of this.stars) {
            star.draw(this.ctx);
        }
        
        // Draw particles
        for (let particle of this.particles) {
            particle.draw(this.ctx);
        }
        
        // Draw player
        if (this.player.isAlive()) {
            this.player.draw(this.ctx);
        }
        
        // Draw enemies
        for (let enemy of this.enemies) {
            enemy.draw(this.ctx);
        }
        
        // Draw UI
        this.drawUI();
        
        // Draw game over
        if (this.gameOver) {
            this.drawGameOver();
        }
    }
    
    drawUI() {
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '20px Arial';
        this.ctx.fillText(`Score: ${this.player.score}`, 10, 30);
        this.ctx.fillText(`Health: ${this.player.health}`, 10, 60);
        this.ctx.fillText(`Wave: ${this.wave}`, 10, 90);
    }
    
    drawGameOver() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(0, 0, 800, 600);
        
        this.ctx.fillStyle = '#ff0000';
        this.ctx.font = '60px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', 400, 250);
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '30px Arial';
        this.ctx.fillText(`Final Score: ${this.player.score}`, 400, 320);
        this.ctx.fillText('Press R to Restart', 400, 370);
        
        this.ctx.textAlign = 'left';
    }
    
    animate() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.animate());
    }
    
    restart() {
        this.player = new Player(375, 500);
        this.enemies = [];
        this.particles = [];
        this.gameOver = false;
        this.wave = 1;
    }
}

// Initialize game
const game = new Game('gameCanvas');

// Restart on R key
window.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
        game.restart();
    }
});

// ============================================
// Arabic Version - ุงููุณุฎุฉ ุงูุนุฑุจูุฉ
// ============================================

// ุตูู ุงููุงุนุจ
ุตูู ูุงุนุจ {
    ููุดุฆ(ุณ, ุต) {
        ูุฐุง.ุณ = ุณ;
        ูุฐุง.ุต = ุต;
        ูุฐุง.ุงูุนุฑุถ = 50;
        ูุฐุง.ุงูุงุฑุชูุงุน = 50;
        ูุฐุง.ุงูุณุฑุนุฉ = 5;
        ูุฐุง.ุงูุตุญุฉ = 100;
        ูุฐุง.ุงูุตุญุฉ_ุงููุตูู = 100;
        ูุฐุง.ุงูุฑุตุงุตุงุช = [];
        ูุฐุง.ุงูููุงุท = 0;
        ูุฐุง.ุงูููู = '#00ff00';
    }

    ุฏุงูุฉ ุชุญุฑู_ูุณุงุฑ() {
        ุงุฐุง (ูุฐุง.ุณ > 0) {
            ูุฐุง.ุณ = ูุฐุง.ุณ - ูุฐุง.ุงูุณุฑุนุฉ;
        }
    }

    ุฏุงูุฉ ุชุญุฑู_ูููู(ุนุฑุถ_ุงูููุญุฉ) {
        ุงุฐุง (ูุฐุง.ุณ + ูุฐุง.ุงูุนุฑุถ < ุนุฑุถ_ุงูููุญุฉ) {
            ูุฐุง.ุณ = ูุฐุง.ุณ + ูุฐุง.ุงูุณุฑุนุฉ;
        }
    }

    ุฏุงูุฉ ุงุทูู() {
        const ุฑุตุงุตุฉ = ุฌุฏูุฏ ุฑุตุงุตุฉ(
            ูุฐุง.ุณ + ูุฐุง.ุงูุนุฑุถ / 2 - 2,
            ูุฐุง.ุต,
            -10,
            '#00ff00'
        );
        ูุฐุง.ุงูุฑุตุงุตุงุช.push(ุฑุตุงุตุฉ);
    }

    ุฏุงูุฉ ุญุฏุซ(ุงุฑุชูุงุน_ุงูููุญุฉ) {
        ูุฐุง.ุงูุฑุตุงุตุงุช = ูุฐุง.ุงูุฑุตุงุตุงุช.filter(ุฑุตุงุตุฉ => {
            ุฑุตุงุตุฉ.ุญุฏุซ();
            ุงุฑุฌุน ุฑุตุงุตุฉ.ุต > 0;
        });
    }

    ุฏุงูุฉ ุงุฑุณู(ุงูุณูุงู) {
        ุงูุณูุงู.fillStyle = ูุฐุง.ุงูููู;
        ุงูุณูุงู.beginPath();
        ุงูุณูุงู.moveTo(ูุฐุง.ุณ + ูุฐุง.ุงูุนุฑุถ / 2, ูุฐุง.ุต);
        ุงูุณูุงู.lineTo(ูุฐุง.ุณ, ูุฐุง.ุต + ูุฐุง.ุงูุงุฑุชูุงุน);
        ุงูุณูุงู.lineTo(ูุฐุง.ุณ + ูุฐุง.ุงูุนุฑุถ, ูุฐุง.ุต + ูุฐุง.ุงูุงุฑุชูุงุน);
        ุงูุณูุงู.closePath();
        ุงูุณูุงู.fill();

        ููู (let ุฑุตุงุตุฉ of ูุฐุง.ุงูุฑุตุงุตุงุช) {
            ุฑุตุงุตุฉ.ุงุฑุณู(ุงูุณูุงู);
        }
    }

    ุฏุงูุฉ ุฎุฐ_ุถุฑุฑ(ุงูููุฏุงุฑ) {
        ูุฐุง.ุงูุตุญุฉ = ูุฐุง.ุงูุตุญุฉ - ุงูููุฏุงุฑ;
        ุงุฐุง (ูุฐุง.ุงูุตุญุฉ < 0) ูุฐุง.ุงูุตุญุฉ = 0;
    }

    ุฏุงูุฉ ุญู() {
        ุงุฑุฌุน ูุฐุง.ุงูุตุญุฉ > 0;
    }
}

// ุตูู ุงูุนุฏู
ุตูู ุนุฏู {
    ููุดุฆ(ุณ, ุต, ุงูููุน) {
        ูุฐุง.ุณ = ุณ;
        ูุฐุง.ุต = ุต;
        ูุฐุง.ุงูุนุฑุถ = 40;
        ูุฐุง.ุงูุงุฑุชูุงุน = 40;
        ูุฐุง.ุงูุณุฑุนุฉ = 2 + Math.random() * 2;
        ูุฐุง.ุงูุตุญุฉ = ุงูููุน === 'boss' ? 50 : 10;
        ูุฐุง.ุงูููุน = ุงูููุน;
        ูุฐุง.ุงูููู = ุงูููุน === 'boss' ? '#ff0000' : '#ff6b6b';
        ูุฐุง.ุงูุฑุตุงุตุงุช = [];
    }

    ุฏุงูุฉ ุญุฏุซ(ุงุฑุชูุงุน_ุงูููุญุฉ) {
        ูุฐุง.ุต = ูุฐุง.ุต + ูุฐุง.ุงูุณุฑุนุฉ;

        ูุฐุง.ุงูุฑุตุงุตุงุช = ูุฐุง.ุงูุฑุตุงุตุงุช.filter(ุฑุตุงุตุฉ => {
            ุฑุตุงุตุฉ.ุญุฏุซ();
            ุงุฑุฌุน ุฑุตุงุตุฉ.ุต < ุงุฑุชูุงุน_ุงูููุญุฉ;
        });
    }

    ุฏุงูุฉ ุงุฑุณู(ุงูุณูุงู) {
        ุงูุณูุงู.fillStyle = ูุฐุง.ุงูููู;
        ุงูุณูุงู.fillRect(ูุฐุง.ุณ, ูุฐุง.ุต, ูุฐุง.ุงูุนุฑุถ, ูุฐุง.ุงูุงุฑุชูุงุน);

        ููู (let ุฑุตุงุตุฉ of ูุฐุง.ุงูุฑุตุงุตุงุช) {
            ุฑุตุงุตุฉ.ุงุฑุณู(ุงูุณูุงู);
        }
    }

    ุฏุงูุฉ ุฎุฐ_ุถุฑุฑ(ุงูููุฏุงุฑ) {
        ูุฐุง.ุงูุตุญุฉ = ูุฐุง.ุงูุตุญุฉ - ุงูููุฏุงุฑ;
        ุงุฑุฌุน ูุฐุง.ุงูุตุญุฉ <= 0;
    }
}

// ุตูู ุงูุฑุตุงุตุฉ
ุตูู ุฑุตุงุตุฉ {
    ููุดุฆ(ุณ, ุต, ุณุฑุนุฉ_ุต, ุงูููู) {
        ูุฐุง.ุณ = ุณ;
        ูุฐุง.ุต = ุต;
        ูุฐุง.ุงูุนุฑุถ = 4;
        ูุฐุง.ุงูุงุฑุชูุงุน = 10;
        ูุฐุง.ุณุฑุนุฉ_ุต = ุณุฑุนุฉ_ุต;
        ูุฐุง.ุงูููู = ุงูููู;
    }

    ุฏุงูุฉ ุญุฏุซ() {
        ูุฐุง.ุต = ูุฐุง.ุต + ูุฐุง.ุณุฑุนุฉ_ุต;
    }

    ุฏุงูุฉ ุงุฑุณู(ุงูุณูุงู) {
        ุงูุณูุงู.fillStyle = ูุฐุง.ุงูููู;
        ุงูุณูุงู.fillRect(ูุฐุง.ุณ, ูุฐุง.ุต, ูุฐุง.ุงูุนุฑุถ, ูุฐุง.ุงูุงุฑุชูุงุน);
    }
}

