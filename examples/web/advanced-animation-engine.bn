// 🎨 Advanced Animation Engine - محرك الرسم والتحريك المتقدم
// Built with Bayan - مبني بلغة البيان
// Inspired by Python's Advanced Shape Engine but better for web!
// مستوحى من محرك الأشكال المتقدم في Python لكن أفضل للويب!

// ============================================
// English Version - النسخة الإنجليزية
// ============================================

// Shape Base Class
class Shape {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.rotation = 0;
        this.scale = 1;
        this.opacity = 1;
        this.color = '#000000';
        this.lineWidth = 2;
        this.fill = false;
        this.animations = [];
        this.time = 0;
    }
    
    // Add keyframe animation
    animate(property, keyframes) {
        this.animations.push({
            property: property,
            keyframes: keyframes.sort((a, b) => a.time - b.time)
        });
        return this;
    }
    
    // Update animations
    updateAnimation(deltaTime) {
        this.time += deltaTime;
        
        for (let anim of this.animations) {
            const value = this.interpolate(anim.keyframes, this.time);
            this[anim.property] = value;
        }
    }
    
    // Linear interpolation between keyframes
    interpolate(keyframes, time) {
        if (keyframes.length === 0) return 0;
        
        // Before first keyframe
        if (time <= keyframes[0].time) {
            return keyframes[0].value;
        }
        
        // After last keyframe
        if (time >= keyframes[keyframes.length - 1].time) {
            return keyframes[keyframes.length - 1].value;
        }
        
        // Find segment
        for (let i = 0; i < keyframes.length - 1; i++) {
            const kf1 = keyframes[i];
            const kf2 = keyframes[i + 1];
            
            if (time >= kf1.time && time <= kf2.time) {
                const t = (time - kf1.time) / (kf2.time - kf1.time);
                return kf1.value + (kf2.value - kf1.value) * t;
            }
        }
        
        return keyframes[keyframes.length - 1].value;
    }
    
    // Apply transformations
    applyTransform(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.scale(this.scale, this.scale);
        ctx.globalAlpha = this.opacity;
    }
    
    restoreTransform(ctx) {
        ctx.restore();
    }
    
    // Override in subclasses
    draw(ctx) {
        // To be implemented by subclasses
    }
}

// Circle Shape
class Circle extends Shape {
    constructor(x, y, radius) {
        super(x, y);
        this.radius = radius;
    }
    
    draw(ctx) {
        this.applyTransform(ctx);
        
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        
        if (this.fill) {
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.stroke();
        
        this.restoreTransform(ctx);
    }
}

// Rectangle Shape
class Rectangle extends Shape {
    constructor(x, y, width, height) {
        super(x, y);
        this.width = width;
        this.height = height;
    }
    
    draw(ctx) {
        this.applyTransform(ctx);
        
        ctx.beginPath();
        ctx.rect(-this.width / 2, -this.height / 2, this.width, this.height);
        
        if (this.fill) {
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.stroke();
        
        this.restoreTransform(ctx);
    }
}

// Line Shape
class Line extends Shape {
    constructor(x1, y1, x2, y2) {
        super(x1, y1);
        this.x2 = x2;
        this.y2 = y2;
    }
    
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x2, this.y2);
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.stroke();
        
        ctx.restore();
    }
}

// Bezier Curve Shape
class BezierCurve extends Shape {
    constructor(x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2) {
        super(x1, y1);
        this.cp1x = cp1x;
        this.cp1y = cp1y;
        this.cp2x = cp2x;
        this.cp2y = cp2y;
        this.x2 = x2;
        this.y2 = y2;
    }
    
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.bezierCurveTo(this.cp1x, this.cp1y, this.cp2x, this.cp2y, this.x2, this.y2);
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.stroke();
        
        ctx.restore();
    }
}

// Polygon Shape
class Polygon extends Shape {
    constructor(points) {
        const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
        const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
        super(centerX, centerY);
        this.points = points;
    }
    
    draw(ctx) {
        this.applyTransform(ctx);
        
        ctx.beginPath();
        const firstPoint = this.points[0];
        ctx.moveTo(firstPoint.x - this.x, firstPoint.y - this.y);
        
        for (let i = 1; i < this.points.length; i++) {
            const point = this.points[i];
            ctx.lineTo(point.x - this.x, point.y - this.y);
        }
        
        ctx.closePath();
        
        if (this.fill) {
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.stroke();
        
        this.restoreTransform(ctx);
    }
}

// Sine Wave Shape
class SineWave extends Shape {
    constructor(x, y, amplitude, frequency, phase, length) {
        super(x, y);
        this.amplitude = amplitude;
        this.frequency = frequency;
        this.phase = phase;
        this.length = length;
        this.segments = 100;
    }
    
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        
        ctx.beginPath();
        
        for (let i = 0; i <= this.segments; i++) {
            const t = (i / this.segments) * this.length;
            const x = this.x + t;
            const y = this.y + this.amplitude * Math.sin(this.frequency * t + this.phase);
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.stroke();
        
        ctx.restore();
    }
}

// Star Shape
class Star extends Shape {
    constructor(x, y, outerRadius, innerRadius, points) {
        super(x, y);
        this.outerRadius = outerRadius;
        this.innerRadius = innerRadius;
        this.points = points;
    }
    
    draw(ctx) {
        this.applyTransform(ctx);
        
        ctx.beginPath();
        
        for (let i = 0; i < this.points * 2; i++) {
            const radius = i % 2 === 0 ? this.outerRadius : this.innerRadius;
            const angle = (Math.PI / this.points) * i;
            const x = radius * Math.cos(angle - Math.PI / 2);
            const y = radius * Math.sin(angle - Math.PI / 2);
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.closePath();
        
        if (this.fill) {
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        
        ctx.strokeStyle = this.color;
        ctx.lineWidth = this.lineWidth;
        ctx.stroke();
        
        this.restoreTransform(ctx);
    }
}

// Animation Engine
class AnimationEngine {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.shapes = [];
        this.isPlaying = false;
        this.lastTime = 0;
        this.backgroundColor = '#ffffff';
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    
    addShape(shape) {
        this.shapes.push(shape);
        return this;
    }
    
    clear() {
        this.shapes = [];
        return this;
    }
    
    update(deltaTime) {
        for (let shape of this.shapes) {
            shape.updateAnimation(deltaTime);
        }
    }
    
    draw() {
        // Clear canvas
        this.ctx.fillStyle = this.backgroundColor;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw all shapes
        for (let shape of this.shapes) {
            shape.draw(this.ctx);
        }
    }
    
    animate(currentTime) {
        if (!this.isPlaying) return;
        
        const deltaTime = (currentTime - this.lastTime) / 1000;
        this.lastTime = currentTime;
        
        this.update(deltaTime);
        this.draw();
        
        requestAnimationFrame((t) => this.animate(t));
    }
    
    play() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.lastTime = performance.now();
        requestAnimationFrame((t) => this.animate(t));
        return this;
    }
    
    pause() {
        this.isPlaying = false;
        return this;
    }
    
    reset() {
        for (let shape of this.shapes) {
            shape.time = 0;
        }
        this.draw();
        return this;
    }
}

// Export for use
const engine = new AnimationEngine('animCanvas');

// ============================================
// Arabic Version - النسخة العربية
// ============================================

// صنف الشكل الأساسي
صنف شكل {
    منشئ(س, ص) {
        هذا.س = س;
        هذا.ص = ص;
        هذا.الدوران = 0;
        هذا.المقياس = 1;
        هذا.الشفافية = 1;
        هذا.اللون = '#000000';
        هذا.عرض_الخط = 2;
        هذا.تعبئة = خطأ;
        هذا.الحركات = [];
        هذا.الوقت = 0;
    }

    دالة حرك(الخاصية, الإطارات_المفتاحية) {
        هذا.الحركات.push({
            خاصية: الخاصية,
            إطارات: الإطارات_المفتاحية.sort((أ, ب) => أ.وقت - ب.وقت)
        });
        ارجع هذا;
    }

    دالة حدث_الحركة(فرق_الوقت) {
        هذا.الوقت = هذا.الوقت + فرق_الوقت;

        لكل (let حركة of هذا.الحركات) {
            const قيمة = هذا.استكمل(حركة.إطارات, هذا.الوقت);
            هذا[حركة.خاصية] = قيمة;
        }
    }

    دالة استكمل(إطارات, وقت) {
        اذا (إطارات.length === 0) ارجع 0;

        اذا (وقت <= إطارات[0].وقت) {
            ارجع إطارات[0].قيمة;
        }

        اذا (وقت >= إطارات[إطارات.length - 1].وقت) {
            ارجع إطارات[إطارات.length - 1].قيمة;
        }

        لكل (let م = 0; م < إطارات.length - 1; م++) {
            const إ1 = إطارات[م];
            const إ2 = إطارات[م + 1];

            اذا (وقت >= إ1.وقت && وقت <= إ2.وقت) {
                const ت = (وقت - إ1.وقت) / (إ2.وقت - إ1.وقت);
                ارجع إ1.قيمة + (إ2.قيمة - إ1.قيمة) * ت;
            }
        }

        ارجع إطارات[إطارات.length - 1].قيمة;
    }

    دالة ارسم(السياق) {
        // يتم تنفيذها في الأصناف الفرعية
    }
}

// صنف الدائرة
صنف دائرة يمتد شكل {
    منشئ(س, ص, نصف_القطر) {
        super(س, ص);
        هذا.نصف_القطر = نصف_القطر;
    }

    دالة ارسم(السياق) {
        السياق.save();
        السياق.translate(هذا.س, هذا.ص);
        السياق.rotate(هذا.الدوران);
        السياق.scale(هذا.المقياس, هذا.المقياس);
        السياق.globalAlpha = هذا.الشفافية;

        السياق.beginPath();
        السياق.arc(0, 0, هذا.نصف_القطر, 0, Math.PI * 2);

        اذا (هذا.تعبئة) {
            السياق.fillStyle = هذا.اللون;
            السياق.fill();
        }

        السياق.strokeStyle = هذا.اللون;
        السياق.lineWidth = هذا.عرض_الخط;
        السياق.stroke();

        السياق.restore();
    }
}

// صنف المستطيل
صنف مستطيل يمتد شكل {
    منشئ(س, ص, العرض, الارتفاع) {
        super(س, ص);
        هذا.العرض = العرض;
        هذا.الارتفاع = الارتفاع;
    }

    دالة ارسم(السياق) {
        السياق.save();
        السياق.translate(هذا.س, هذا.ص);
        السياق.rotate(هذا.الدوران);
        السياق.scale(هذا.المقياس, هذا.المقياس);
        السياق.globalAlpha = هذا.الشفافية;

        السياق.beginPath();
        السياق.rect(-هذا.العرض / 2, -هذا.الارتفاع / 2, هذا.العرض, هذا.الارتفاع);

        اذا (هذا.تعبئة) {
            السياق.fillStyle = هذا.اللون;
            السياق.fill();
        }

        السياق.strokeStyle = هذا.اللون;
        السياق.lineWidth = هذا.عرض_الخط;
        السياق.stroke();

        السياق.restore();
    }
}

// صنف النجمة
صنف نجمة يمتد شكل {
    منشئ(س, ص, نصف_قطر_خارجي, نصف_قطر_داخلي, عدد_النقاط) {
        super(س, ص);
        هذا.نصف_قطر_خارجي = نصف_قطر_خارجي;
        هذا.نصف_قطر_داخلي = نصف_قطر_داخلي;
        هذا.عدد_النقاط = عدد_النقاط;
    }

    دالة ارسم(السياق) {
        السياق.save();
        السياق.translate(هذا.س, هذا.ص);
        السياق.rotate(هذا.الدوران);
        السياق.scale(هذا.المقياس, هذا.المقياس);
        السياق.globalAlpha = هذا.الشفافية;

        السياق.beginPath();

        لكل (let م = 0; م < هذا.عدد_النقاط * 2; م++) {
            const نصف_القطر = م % 2 === 0 ? هذا.نصف_قطر_خارجي : هذا.نصف_قطر_داخلي;
            const الزاوية = (Math.PI / هذا.عدد_النقاط) * م;
            const س = نصف_القطر * Math.cos(الزاوية - Math.PI / 2);
            const ص = نصف_القطر * Math.sin(الزاوية - Math.PI / 2);

            اذا (م === 0) {
                السياق.moveTo(س, ص);
            } والا {
                السياق.lineTo(س, ص);
            }
        }

        السياق.closePath();

        اذا (هذا.تعبئة) {
            السياق.fillStyle = هذا.اللون;
            السياق.fill();
        }

        السياق.strokeStyle = هذا.اللون;
        السياق.lineWidth = هذا.عرض_الخط;
        السياق.stroke();

        السياق.restore();
    }
}

// صنف محرك الحركة
صنف محرك_حركة {
    منشئ(معرف_اللوحة) {
        هذا.اللوحة = document.getElementById(معرف_اللوحة);
        هذا.السياق = هذا.اللوحة.getContext('2d');
        هذا.الأشكال = [];
        هذا.يعمل = خطأ;
        هذا.الوقت_السابق = 0;
        هذا.لون_الخلفية = '#ffffff';
    }

    دالة أضف_شكل(شكل) {
        هذا.الأشكال.push(شكل);
        ارجع هذا;
    }

    دالة امسح() {
        هذا.الأشكال = [];
        ارجع هذا;
    }

    دالة حدث(فرق_الوقت) {
        لكل (let شكل of هذا.الأشكال) {
            شكل.حدث_الحركة(فرق_الوقت);
        }
    }

    دالة ارسم() {
        هذا.السياق.fillStyle = هذا.لون_الخلفية;
        هذا.السياق.fillRect(0, 0, هذا.اللوحة.width, هذا.اللوحة.height);

        لكل (let شكل of هذا.الأشكال) {
            شكل.ارسم(هذا.السياق);
        }
    }

    دالة شغل() {
        اذا (هذا.يعمل) ارجع;
        هذا.يعمل = صحيح;
        هذا.الوقت_السابق = performance.now();
        requestAnimationFrame((و) => هذا.حرك(و));
        ارجع هذا;
    }

    دالة حرك(الوقت_الحالي) {
        اذا (!هذا.يعمل) ارجع;

        const فرق_الوقت = (الوقت_الحالي - هذا.الوقت_السابق) / 1000;
        هذا.الوقت_السابق = الوقت_الحالي;

        هذا.حدث(فرق_الوقت);
        هذا.ارسم();

        requestAnimationFrame((و) => هذا.حرك(و));
    }
}

