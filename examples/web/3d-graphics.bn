// 🎮 3D Graphics with Bayan - رسوميات ثلاثية الأبعاد بلغة البيان
// Advanced 3D rendering using Canvas and transforms
// رسم ثلاثي الأبعاد متقدم باستخدام Canvas والتحويلات

// ============================================
// English Version - النسخة الإنجليزية
// ============================================

// 3D Point Class
class Point3D {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    rotateX(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const y = this.y * cos - this.z * sin;
        const z = this.y * sin + this.z * cos;
        return new Point3D(this.x, y, z);
    }
    
    rotateY(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = this.x * cos + this.z * sin;
        const z = -this.x * sin + this.z * cos;
        return new Point3D(x, this.y, z);
    }
    
    rotateZ(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = this.x * cos - this.y * sin;
        const y = this.x * sin + this.y * cos;
        return new Point3D(x, y, this.z);
    }
    
    project(width, height, fov, distance) {
        const factor = fov / (distance + this.z);
        const x = this.x * factor + width / 2;
        const y = -this.y * factor + height / 2;
        return { x, y, z: this.z };
    }
}

// 3D Cube Class
class Cube3D {
    constructor(size, color) {
        this.size = size;
        this.color = color;
        this.angleX = 0;
        this.angleY = 0;
        this.angleZ = 0;
        
        // Define cube vertices
        const s = size / 2;
        this.vertices = [
            new Point3D(-s, -s, -s),
            new Point3D(s, -s, -s),
            new Point3D(s, s, -s),
            new Point3D(-s, s, -s),
            new Point3D(-s, -s, s),
            new Point3D(s, -s, s),
            new Point3D(s, s, s),
            new Point3D(-s, s, s)
        ];
        
        // Define cube faces
        this.faces = [
            [0, 1, 2, 3], // Front
            [4, 5, 6, 7], // Back
            [0, 1, 5, 4], // Bottom
            [2, 3, 7, 6], // Top
            [0, 3, 7, 4], // Left
            [1, 2, 6, 5]  // Right
        ];
        
        this.faceColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1',
            '#FFA07A', '#98D8C8', '#F7DC6F'
        ];
    }
    
    update(speed) {
        this.angleX += speed;
        this.angleY += speed * 0.7;
        this.angleZ += speed * 0.5;
    }
    
    draw(ctx, width, height) {
        // Rotate and project vertices
        const projected = this.vertices.map(v => {
            let rotated = v.rotateX(this.angleX);
            rotated = rotated.rotateY(this.angleY);
            rotated = rotated.rotateZ(this.angleZ);
            return rotated.project(width, height, 400, 4);
        });
        
        // Calculate face depths for sorting
        const facesWithDepth = this.faces.map((face, i) => {
            const avgZ = face.reduce((sum, idx) => sum + projected[idx].z, 0) / face.length;
            return { face, color: this.faceColors[i], depth: avgZ };
        });
        
        // Sort faces by depth (painter's algorithm)
        facesWithDepth.sort((a, b) => a.depth - b.depth);
        
        // Draw faces
        for (let { face, color } of facesWithDepth) {
            ctx.beginPath();
            ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
            
            for (let i = 1; i < face.length; i++) {
                ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
            }
            
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }
}

// 3D Scene Manager
class Scene3D {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.objects = [];
        this.animationId = null;
        this.rotationSpeed = 0.02;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }
    
    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }
    
    addObject(obj) {
        this.objects.push(obj);
    }
    
    update() {
        for (let obj of this.objects) {
            if (obj.update) {
                obj.update(this.rotationSpeed);
            }
        }
    }
    
    draw() {
        // Clear canvas
        this.ctx.fillStyle = '#1a1a2e';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid
        this.drawGrid();
        
        // Draw objects
        for (let obj of this.objects) {
            obj.draw(this.ctx, this.canvas.width, this.canvas.height);
        }
    }
    
    drawGrid() {
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        this.ctx.lineWidth = 1;
        
        const step = 50;
        
        // Vertical lines
        for (let x = 0; x < this.canvas.width; x += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = 0; y < this.canvas.height; y += step) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
    }
    
    animate() {
        this.update();
        this.draw();
        this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    start() {
        this.animate();
    }
    
    setSpeed(speed) {
        this.rotationSpeed = speed;
    }
}

// Initialize scene
const scene = new Scene3D('canvas3d');

// Add multiple cubes
const cube1 = new Cube3D(150, '#FF6B6B');
scene.addObject(cube1);

scene.start();

// ============================================
// Arabic Version - النسخة العربية
// ============================================

// صنف نقطة ثلاثية الأبعاد
صنف نقطة_3د {
    منشئ(س, ص, ع) {
        هذا.س = س;
        هذا.ص = ص;
        هذا.ع = ع;
    }
    
    دالة دور_س(الزاوية) {
        const جتا = Math.cos(الزاوية);
        const جا = Math.sin(الزاوية);
        const ص = هذا.ص * جتا - هذا.ع * جا;
        const ع = هذا.ص * جا + هذا.ع * جتا;
        ارجع جديد نقطة_3د(هذا.س, ص, ع);
    }
    
    دالة دور_ص(الزاوية) {
        const جتا = Math.cos(الزاوية);
        const جا = Math.sin(الزاوية);
        const س = هذا.س * جتا + هذا.ع * جا;
        const ع = -هذا.س * جا + هذا.ع * جتا;
        ارجع جديد نقطة_3د(س, هذا.ص, ع);
    }
    
    دالة اسقط(العرض, الارتفاع, مجال_الرؤية, المسافة) {
        const العامل = مجال_الرؤية / (المسافة + هذا.ع);
        const س = هذا.س * العامل + العرض / 2;
        const ص = -هذا.ص * العامل + الارتفاع / 2;
        ارجع { س, ص, ع: هذا.ع };
    }
}

// صنف مكعب ثلاثي الأبعاد
صنف مكعب_3د {
    منشئ(الحجم, اللون) {
        هذا.الحجم = الحجم;
        هذا.اللون = اللون;
        هذا.زاوية_س = 0;
        هذا.زاوية_ص = 0;
        هذا.زاوية_ع = 0;
        
        const ح = الحجم / 2;
        هذا.الرؤوس = [
            جديد نقطة_3د(-ح, -ح, -ح),
            جديد نقطة_3د(ح, -ح, -ح),
            جديد نقطة_3د(ح, ح, -ح),
            جديد نقطة_3د(-ح, ح, -ح),
            جديد نقطة_3د(-ح, -ح, ح),
            جديد نقطة_3د(ح, -ح, ح),
            جديد نقطة_3د(ح, ح, ح),
            جديد نقطة_3د(-ح, ح, ح)
        ];
        
        هذا.الوجوه = [
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [0, 1, 5, 4],
            [2, 3, 7, 6],
            [0, 3, 7, 4],
            [1, 2, 6, 5]
        ];
        
        هذا.ألوان_الوجوه = [
            '#FF6B6B', '#4ECDC4', '#45B7D1',
            '#FFA07A', '#98D8C8', '#F7DC6F'
        ];
    }
    
    دالة حدث(السرعة) {
        هذا.زاوية_س = هذا.زاوية_س + السرعة;
        هذا.زاوية_ص = هذا.زاوية_ص + السرعة * 0.7;
        هذا.زاوية_ع = هذا.زاوية_ع + السرعة * 0.5;
    }
    
    دالة ارسم(السياق, العرض, الارتفاع) {
        const المسقط = هذا.الرؤوس.map(ر => {
            let مدور = ر.دور_س(هذا.زاوية_س);
            مدور = مدور.دور_ص(هذا.زاوية_ص);
            ارجع مدور.اسقط(العرض, الارتفاع, 400, 4);
        });
        
        const الوجوه_بالعمق = هذا.الوجوه.map((وجه, م) => {
            const متوسط_ع = وجه.reduce((مجموع, فهرس) => مجموع + المسقط[فهرس].ع, 0) / وجه.length;
            ارجع { وجه, لون: هذا.ألوان_الوجوه[م], عمق: متوسط_ع };
        });
        
        الوجوه_بالعمق.sort((أ, ب) => أ.عمق - ب.عمق);
        
        لكل (let { وجه, لون } of الوجوه_بالعمق) {
            السياق.beginPath();
            السياق.moveTo(المسقط[وجه[0]].س, المسقط[وجه[0]].ص);
            
            لكل (let ع = 1; ع < وجه.length; ع++) {
                السياق.lineTo(المسقط[وجه[ع]].س, المسقط[وجه[ع]].ص);
            }
            
            السياق.closePath();
            السياق.fillStyle = لون;
            السياق.fill();
            السياق.strokeStyle = '#000';
            السياق.lineWidth = 2;
            السياق.stroke();
        }
    }
}

