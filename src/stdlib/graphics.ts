/**
 * مكتبة الجرافيك والرسم للغة البيان
 */

/**
 * الألوان
 */
export class لون {
  constructor(
    public أحمر: number,
    public أخضر: number,
    public أزرق: number,
    public شفافية: number = 1
  ) {
    this.أحمر = Math.max(0, Math.min(255, أحمر));
    this.أخضر = Math.max(0, Math.min(255, أخضر));
    this.أزرق = Math.max(0, Math.min(255, أزرق));
    this.شفافية = Math.max(0, Math.min(1, شفافية));
  }

  /**
   * تحويل إلى RGB
   */
  إلى_نص(): string {
    if (this.شفافية < 1) {
      return `rgba(${this.أحمر}, ${this.أخضر}, ${this.أزرق}, ${this.شفافية})`;
    }
    return `rgb(${this.أحمر}, ${this.أخضر}, ${this.أزرق})`;
  }

  /**
   * تحويل إلى Hex
   */
  إلى_هيكس(): string {
    const إلى_هيكس = (ع: number) => {
      const هيكس = Math.round(ع).toString(16);
      return هيكس.length === 1 ? '0' + هيكس : هيكس;
    };

    return `#${إلى_هيكس(this.أحمر)}${إلى_هيكس(this.أخضر)}${إلى_هيكس(this.أزرق)}`;
  }

  /**
   * إنشاء لون من Hex
   */
  static من_هيكس(هيكس: string): لون {
    هيكس = هيكس.replace('#', '');
    
    const أحمر = parseInt(هيكس.substring(0, 2), 16);
    const أخضر = parseInt(هيكس.substring(2, 4), 16);
    const أزرق = parseInt(هيكس.substring(4, 6), 16);
    
    return new لون(أحمر, أخضر, أزرق);
  }

  /**
   * إنشاء لون من HSL
   */
  static من_HSL(صبغة: number, تشبع: number, إضاءة: number): لون {
    صبغة = صبغة % 360;
    تشبع = Math.max(0, Math.min(1, تشبع));
    إضاءة = Math.max(0, Math.min(1, إضاءة));

    const ج = (1 - Math.abs(2 * إضاءة - 1)) * تشبع;
    const س = ج * (1 - Math.abs(((صبغة / 60) % 2) - 1));
    const م = إضاءة - ج / 2;

    let أحمر = 0, أخضر = 0, أزرق = 0;

    if (صبغة < 60) {
      أحمر = ج; أخضر = س; أزرق = 0;
    } else if (صبغة < 120) {
      أحمر = س; أخضر = ج; أزرق = 0;
    } else if (صبغة < 180) {
      أحمر = 0; أخضر = ج; أزرق = س;
    } else if (صبغة < 240) {
      أحمر = 0; أخضر = س; أزرق = ج;
    } else if (صبغة < 300) {
      أحمر = س; أخضر = 0; أزرق = ج;
    } else {
      أحمر = ج; أخضر = 0; أزرق = س;
    }

    return new لون(
      Math.round((أحمر + م) * 255),
      Math.round((أخضر + م) * 255),
      Math.round((أزرق + م) * 255)
    );
  }
}

/**
 * الألوان المحددة مسبقاً
 */
export const الألوان = {
  أحمر: new لون(255, 0, 0),
  أخضر: new لون(0, 255, 0),
  أزرق: new لون(0, 0, 255),
  أصفر: new لون(255, 255, 0),
  أرجواني: new لون(255, 0, 255),
  سماوي: new لون(0, 255, 255),
  أبيض: new لون(255, 255, 255),
  أسود: new لون(0, 0, 0),
  رمادي: new لون(128, 128, 128),
  برتقالي: new لون(255, 165, 0),
  وردي: new لون(255, 192, 203),
  بنفسجي: new لون(128, 0, 128),
  بني: new لون(165, 42, 42),
  ذهبي: new لون(255, 215, 0),
  فضي: new لون(192, 192, 192),
};

/**
 * النقطة
 */
export class نقطة {
  constructor(public س: number, public ص: number) {}

  /**
   * المسافة إلى نقطة أخرى
   */
  مسافة_إلى(نقطة_أخرى: نقطة): number {
    const فرق_س = this.س - نقطة_أخرى.س;
    const فرق_ص = this.ص - نقطة_أخرى.ص;
    return Math.sqrt(فرق_س * فرق_س + فرق_ص * فرق_ص);
  }

  /**
   * نسخ النقطة
   */
  نسخ(): نقطة {
    return new نقطة(this.س, this.ص);
  }
}

/**
 * المستطيل
 */
export class مستطيل {
  constructor(
    public س: number,
    public ص: number,
    public عرض: number,
    public ارتفاع: number
  ) {}

  /**
   * التحقق من احتواء نقطة
   */
  يحتوي_نقطة(نقطة: نقطة): boolean {
    return (
      نقطة.س >= this.س &&
      نقطة.س <= this.س + this.عرض &&
      نقطة.ص >= this.ص &&
      نقطة.ص <= this.ص + this.ارتفاع
    );
  }

  /**
   * التحقق من التقاطع مع مستطيل آخر
   */
  يتقاطع_مع(مستطيل_آخر: مستطيل): boolean {
    return !(
      this.س + this.عرض < مستطيل_آخر.س ||
      مستطيل_آخر.س + مستطيل_آخر.عرض < this.س ||
      this.ص + this.ارتفاع < مستطيل_آخر.ص ||
      مستطيل_آخر.ص + مستطيل_آخر.ارتفاع < this.ص
    );
  }

  /**
   * المساحة
   */
  مساحة(): number {
    return this.عرض * this.ارتفاع;
  }

  /**
   * المحيط
   */
  محيط(): number {
    return 2 * (this.عرض + this.ارتفاع);
  }
}

/**
 * الدائرة
 */
export class دائرة {
  constructor(
    public مركز: نقطة,
    public نصف_قطر: number
  ) {}

  /**
   * التحقق من احتواء نقطة
   */
  يحتوي_نقطة(نقطة: نقطة): boolean {
    return this.مركز.مسافة_إلى(نقطة) <= this.نصف_قطر;
  }

  /**
   * التحقق من التقاطع مع دائرة أخرى
   */
  يتقاطع_مع(دائرة_أخرى: دائرة): boolean {
    const مسافة = this.مركز.مسافة_إلى(دائرة_أخرى.مركز);
    return مسافة <= this.نصف_قطر + دائرة_أخرى.نصف_قطر;
  }

  /**
   * المساحة
   */
  مساحة(): number {
    return Math.PI * this.نصف_قطر * this.نصف_قطر;
  }

  /**
   * المحيط
   */
  محيط(): number {
    return 2 * Math.PI * this.نصف_قطر;
  }
}

/**
 * المثلث
 */
export class مثلث {
  constructor(
    public نقطة1: نقطة,
    public نقطة2: نقطة,
    public نقطة3: نقطة
  ) {}

  /**
   * المساحة (باستخدام صيغة هيرون)
   */
  مساحة(): number {
    const ضلع1 = this.نقطة1.مسافة_إلى(this.نقطة2);
    const ضلع2 = this.نقطة2.مسافة_إلى(this.نقطة3);
    const ضلع3 = this.نقطة3.مسافة_إلى(this.نقطة1);
    
    const نصف_محيط = (ضلع1 + ضلع2 + ضلع3) / 2;
    
    return Math.sqrt(
      نصف_محيط *
      (نصف_محيط - ضلع1) *
      (نصف_محيط - ضلع2) *
      (نصف_محيط - ضلع3)
    );
  }

  /**
   * المحيط
   */
  محيط(): number {
    return (
      this.نقطة1.مسافة_إلى(this.نقطة2) +
      this.نقطة2.مسافة_إلى(this.نقطة3) +
      this.نقطة3.مسافة_إلى(this.نقطة1)
    );
  }
}

/**
 * التحويلات الهندسية
 */
export const التحويلات = {
  /**
   * الدوران حول نقطة
   */
  دوران: (ن: نقطة, مركز: نقطة, زاوية: number): نقطة => {
    const راديان = (زاوية * Math.PI) / 180;
    const جيب = Math.sin(راديان);
    const جيب_تمام = Math.cos(راديان);

    const س_منقول = ن.س - مركز.س;
    const ص_منقول = ن.ص - مركز.ص;

    const س_جديد = س_منقول * جيب_تمام - ص_منقول * جيب + مركز.س;
    const ص_جديد = س_منقول * جيب + ص_منقول * جيب_تمام + مركز.ص;

    return new نقطة(س_جديد, ص_جديد);
  },

  /**
   * التكبير/التصغير
   */
  تكبير: (ن: نقطة, مركز: نقطة, عامل: number): نقطة => {
    const س_جديد = مركز.س + (ن.س - مركز.س) * عامل;
    const ص_جديد = مركز.ص + (ن.ص - مركز.ص) * عامل;
    return new نقطة(س_جديد, ص_جديد);
  },

  /**
   * الانعكاس حول محور X
   */
  انعكاس_أفقي: (ن: نقطة, محور_ص: number = 0): نقطة => {
    return new نقطة(ن.س, 2 * محور_ص - ن.ص);
  },

  /**
   * الانعكاس حول محور Y
   */
  انعكاس_عمودي: (ن: نقطة, محور_س: number = 0): نقطة => {
    return new نقطة(2 * محور_س - ن.س, ن.ص);
  },

  /**
   * الإزاحة
   */
  إزاحة: (ن: نقطة, إزاحة_س: number, إزاحة_ص: number): نقطة => {
    return new نقطة(ن.س + إزاحة_س, ن.ص + إزاحة_ص);
  },
};

/**
 * منحنيات بيزيه
 */
export const بيزيه = {
  /**
   * منحنى بيزيه التربيعي
   */
  تربيعي: (نقطة_بداية: نقطة, نقطة_تحكم: نقطة, نقطة_نهاية: نقطة, ت: number): نقطة => {
    const واحد_ناقص_ت = 1 - ت;
    
    const س = 
      واحد_ناقص_ت * واحد_ناقص_ت * نقطة_بداية.س +
      2 * واحد_ناقص_ت * ت * نقطة_تحكم.س +
      ت * ت * نقطة_نهاية.س;
    
    const ص = 
      واحد_ناقص_ت * واحد_ناقص_ت * نقطة_بداية.ص +
      2 * واحد_ناقص_ت * ت * نقطة_تحكم.ص +
      ت * ت * نقطة_نهاية.ص;
    
    return new نقطة(س, ص);
  },

  /**
   * منحنى بيزيه التكعيبي
   */
  تكعيبي: (
    نقطة_بداية: نقطة,
    نقطة_تحكم1: نقطة,
    نقطة_تحكم2: نقطة,
    نقطة_نهاية: نقطة,
    ت: number
  ): نقطة => {
    const واحد_ناقص_ت = 1 - ت;
    
    const س = 
      واحد_ناقص_ت * واحد_ناقص_ت * واحد_ناقص_ت * نقطة_بداية.س +
      3 * واحد_ناقص_ت * واحد_ناقص_ت * ت * نقطة_تحكم1.س +
      3 * واحد_ناقص_ت * ت * ت * نقطة_تحكم2.س +
      ت * ت * ت * نقطة_نهاية.س;
    
    const ص = 
      واحد_ناقص_ت * واحد_ناقص_ت * واحد_ناقص_ت * نقطة_بداية.ص +
      3 * واحد_ناقص_ت * واحد_ناقص_ت * ت * نقطة_تحكم1.ص +
      3 * واحد_ناقص_ت * ت * ت * نقطة_تحكم2.ص +
      ت * ت * ت * نقطة_نهاية.ص;
    
    return new نقطة(س, ص);
  },
};

