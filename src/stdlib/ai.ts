/**
 * مكتبة الذكاء الاصطناعي للغة البيان
 */

/**
 * الشبكات العصبية
 */

/**
 * دالة التنشيط
 */
export type دالة_تنشيط = (س: number) => number;

/**
 * دوال التنشيط الشائعة
 */
export const دوال_التنشيط = {
  /**
   * Sigmoid
   */
  سيجمويد: (س: number): number => {
    return 1 / (1 + Math.exp(-س));
  },

  /**
   * مشتقة Sigmoid
   */
  مشتقة_سيجمويد: (س: number): number => {
    const سيج = دوال_التنشيط.سيجمويد(س);
    return سيج * (1 - سيج);
  },

  /**
   * ReLU (Rectified Linear Unit)
   */
  ريلو: (س: number): number => {
    return Math.max(0, س);
  },

  /**
   * مشتقة ReLU
   */
  مشتقة_ريلو: (س: number): number => {
    return س > 0 ? 1 : 0;
  },

  /**
   * Tanh
   */
  تانه: (س: number): number => {
    return Math.tanh(س);
  },

  /**
   * مشتقة Tanh
   */
  مشتقة_تانه: (س: number): number => {
    const تانه = Math.tanh(س);
    return 1 - تانه * تانه;
  },

  /**
   * Leaky ReLU
   */
  ريلو_متسرب: (س: number, ألفا: number = 0.01): number => {
    return س > 0 ? س : ألفا * س;
  },

  /**
   * Softmax (للمصفوفات)
   */
  سوفت_ماكس: (مصفوفة: number[]): number[] => {
    const أقصى = Math.max(...مصفوفة);
    const أس = مصفوفة.map(س => Math.exp(س - أقصى));
    const مجموع = أس.reduce((م, ق) => م + ق, 0);
    return أس.map(ق => ق / مجموع);
  },
};

/**
 * دوال الخسارة
 */
export const دوال_الخسارة = {
  /**
   * Mean Squared Error
   */
  خطأ_تربيعي_متوسط: (متوقع: number[], فعلي: number[]): number => {
    if (متوقع.length !== فعلي.length) {
      throw new Error('يجب أن يكون للمصفوفتين نفس الطول');
    }
    
    const مجموع = متوقع.reduce((م, ق, ف) => {
      const فرق = ق - فعلي[ف];
      return م + فرق * فرق;
    }, 0);
    
    return مجموع / متوقع.length;
  },

  /**
   * Cross Entropy
   */
  إنتروبيا_تقاطعية: (متوقع: number[], فعلي: number[]): number => {
    if (متوقع.length !== فعلي.length) {
      throw new Error('يجب أن يكون للمصفوفتين نفس الطول');
    }
    
    const مجموع = متوقع.reduce((م, ق, ف) => {
      const ف_قيمة = فعلي[ف];
      // تجنب log(0)
      const قيمة_آمنة = Math.max(ف_قيمة, 1e-15);
      return م - ق * Math.log(قيمة_آمنة);
    }, 0);
    
    return مجموع;
  },

  /**
   * Mean Absolute Error
   */
  خطأ_مطلق_متوسط: (متوقع: number[], فعلي: number[]): number => {
    if (متوقع.length !== فعلي.length) {
      throw new Error('يجب أن يكون للمصفوفتين نفس الطول');
    }
    
    const مجموع = متوقع.reduce((م, ق, ف) => {
      return م + Math.abs(ق - فعلي[ف]);
    }, 0);
    
    return مجموع / متوقع.length;
  },
};

/**
 * التعلم الآلي - خوارزميات التصنيف
 */
export const التصنيف = {
  /**
   * K-Nearest Neighbors (KNN)
   */
  أقرب_ك_جيران: (
    بيانات_تدريب: { ميزات: number[]; تصنيف: any }[],
    نقطة_اختبار: number[],
    ك: number = 3
  ): any => {
    // حساب المسافات
    const مسافات = بيانات_تدريب.map(نقطة => {
      const مسافة = Math.sqrt(
        نقطة.ميزات.reduce((مجموع, ميزة, فهرس) => {
          const فرق = ميزة - نقطة_اختبار[فهرس];
          return مجموع + فرق * فرق;
        }, 0)
      );
      
      return { مسافة, تصنيف: نقطة.تصنيف };
    });

    // ترتيب حسب المسافة
    مسافات.sort((أ, ب) => أ.مسافة - ب.مسافة);

    // أخذ أقرب ك جيران
    const أقرب_جيران = مسافات.slice(0, ك);

    // التصويت على التصنيف الأكثر شيوعاً
    const تصويت = new Map<any, number>();
    for (const جار of أقرب_جيران) {
      const عدد = تصويت.get(جار.تصنيف) || 0;
      تصويت.set(جار.تصنيف, عدد + 1);
    }

    // إيجاد التصنيف الأكثر شيوعاً
    let أفضل_تصنيف = أقرب_جيران[0].تصنيف;
    let أقصى_أصوات = 0;
    
    for (const [تصنيف, أصوات] of تصويت) {
      if (أصوات > أقصى_أصوات) {
        أقصى_أصوات = أصوات;
        أفضل_تصنيف = تصنيف;
      }
    }

    return أفضل_تصنيف;
  },

  /**
   * Naive Bayes Classifier (مبسط)
   */
  بايز_ساذج: (
    بيانات_تدريب: { ميزات: number[]; تصنيف: string }[],
    نقطة_اختبار: number[]
  ): string => {
    // حساب احتماليات التصنيفات
    const تصنيفات = new Map<string, number>();
    for (const نقطة of بيانات_تدريب) {
      const عدد = تصنيفات.get(نقطة.تصنيف) || 0;
      تصنيفات.set(نقطة.تصنيف, عدد + 1);
    }

    // حساب الاحتمالات لكل تصنيف
    const احتماليات = new Map<string, number>();
    
    for (const [تصنيف, عدد] of تصنيفات) {
      const احتمال_أولي = عدد / بيانات_تدريب.length;
      
      // حساب احتمال الميزات بافتراض الاستقلالية
      const نقاط_التصنيف = بيانات_تدريب.filter(ن => ن.تصنيف === تصنيف);
      
      let احتمال_مشترك = احتمال_أولي;
      
      for (let ف = 0; ف < نقطة_اختبار.length; ف++) {
        const قيمة = نقطة_اختبار[ف];
        
        // حساب متوسط وانحراف معياري للميزة
        const قيم = نقاط_التصنيف.map(ن => ن.ميزات[ف]);
        const متوسط = قيم.reduce((م, ق) => م + ق, 0) / قيم.length;
        const تباين = قيم.reduce((م, ق) => م + Math.pow(ق - متوسط, 2), 0) / قيم.length;
        const انحراف = Math.sqrt(تباين);
        
        // احتمال غاوسي
        const احتمال_ميزة = (1 / (Math.sqrt(2 * Math.PI) * انحراف)) *
          Math.exp(-Math.pow(قيمة - متوسط, 2) / (2 * تباين));
        
        احتمال_مشترك *= احتمال_ميزة;
      }
      
      احتماليات.set(تصنيف, احتمال_مشترك);
    }

    // إيجاد التصنيف بأعلى احتمال
    let أفضل_تصنيف = '';
    let أقصى_احتمال = 0;
    
    for (const [تصنيف, احتمال] of احتماليات) {
      if (احتمال > أقصى_احتمال) {
        أقصى_احتمال = احتمال;
        أفضل_تصنيف = تصنيف;
      }
    }

    return أفضل_تصنيف;
  },
};

/**
 * التعلم الآلي - الانحدار
 */
export const الانحدار = {
  /**
   * الانحدار الخطي البسيط
   */
  انحدار_خطي_بسيط: (
    نقاط: { س: number; ص: number }[]
  ): { ميل: number; تقاطع: number; توقع: (س: number) => number } => {
    const ن = نقاط.length;
    
    // حساب المتوسطات
    const متوسط_س = نقاط.reduce((م, ن) => م + ن.س, 0) / ن;
    const متوسط_ص = نقاط.reduce((م, ن) => م + ن.ص, 0) / ن;
    
    // حساب الميل
    let بسط = 0;
    let مقام = 0;
    
    for (const نقطة of نقاط) {
      بسط += (نقطة.س - متوسط_س) * (نقطة.ص - متوسط_ص);
      مقام += Math.pow(نقطة.س - متوسط_س, 2);
    }
    
    const ميل = بسط / مقام;
    const تقاطع = متوسط_ص - ميل * متوسط_س;
    
    return {
      ميل,
      تقاطع,
      توقع: (س: number) => ميل * س + تقاطع,
    };
  },
};

/**
 * التجميع (Clustering)
 */
export const التجميع = {
  /**
   * K-Means Clustering
   */
  ك_متوسطات: (
    نقاط: number[][],
    ك: number,
    تكرارات_قصوى: number = 100
  ): { مراكز: number[][]; تجميعات: number[] } => {
    // اختيار مراكز أولية عشوائية
    const مراكز: number[][] = [];
    for (let ط = 0; ط < ك; ط++) {
      const فهرس_عشوائي = Math.floor(Math.random() * نقاط.length);
      مراكز.push([...نقاط[فهرس_عشوائي]]);
    }

    let تجميعات: number[] = new Array(نقاط.length).fill(0);

    for (let تكرار = 0; تكرار < تكرارات_قصوى; تكرار++) {
      // تعيين كل نقطة لأقرب مركز
      const تجميعات_جديدة: number[] = [];
      
      for (const نقطة of نقاط) {
        let أقرب_مركز = 0;
        let أقل_مسافة = Infinity;
        
        for (let م = 0; م < مراكز.length; م++) {
          const مسافة = Math.sqrt(
            نقطة.reduce((مجموع, قيمة, فهرس) => {
              const فرق = قيمة - مراكز[م][فهرس];
              return مجموع + فرق * فرق;
            }, 0)
          );
          
          if (مسافة < أقل_مسافة) {
            أقل_مسافة = مسافة;
            أقرب_مركز = م;
          }
        }
        
        تجميعات_جديدة.push(أقرب_مركز);
      }

      // التحقق من التقارب
      if (JSON.stringify(تجميعات) === JSON.stringify(تجميعات_جديدة)) {
        break;
      }

      تجميعات = تجميعات_جديدة;

      // تحديث المراكز
      for (let م = 0; م < ك; م++) {
        const نقاط_المجموعة = نقاط.filter((_, ف) => تجميعات[ف] === م);
        
        if (نقاط_المجموعة.length > 0) {
          const بعد = نقاط[0].length;
          const مركز_جديد: number[] = new Array(بعد).fill(0);
          
          for (const نقطة of نقاط_المجموعة) {
            for (let ب = 0; ب < بعد; ب++) {
              مركز_جديد[ب] += نقطة[ب];
            }
          }
          
          for (let ب = 0; ب < بعد; ب++) {
            مركز_جديد[ب] /= نقاط_المجموعة.length;
          }
          
          مراكز[م] = مركز_جديد;
        }
      }
    }

    return { مراكز, تجميعات };
  },
};

