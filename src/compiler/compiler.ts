/**
 * المترجم (Compiler) للغة البيان
 * يحول كود البيان إلى JavaScript
 */

import * as AST from '../ast/index.js';

export interface CompilerOptions {
  target?: 'es5' | 'es2015' | 'es2020' | 'esnext';
  module?: 'commonjs' | 'esm';
  includeRuntime?: boolean;
  sourceMaps?: boolean;
}

export class Compiler {
  private indentLevel = 0;
  private output = '';
  private options: Required<CompilerOptions>;

  constructor(options: CompilerOptions = {}) {
    this.options = {
      target: options.target || 'es2020',
      module: options.module || 'esm',
      includeRuntime: options.includeRuntime !== false,
      sourceMaps: options.sourceMaps || false
    };
  }

  /**
   * ترجمة البرنامج الكامل
   */
  compile(program: AST.Program): string {
    this.output = '';
    this.indentLevel = 0;

    // إضافة رأس الملف
    this.emitLine('// Generated by Albayan Compiler');
    this.emitLine(`// Target: ${this.options.target}, Module: ${this.options.module}`);
    this.emitLine('');

    // استيراد المكتبة المنطقية إذا لزم الأمر
    if (this.options.includeRuntime) {
      if (this.options.module === 'esm') {
        this.emitLine("import { LogicEngine, Fact, Rule, Predicate, Term } from '@albayan/runtime';");
      } else {
        this.emitLine("const { LogicEngine, Fact, Rule, Predicate, Term } = require('@albayan/runtime');");
      }
      this.emitLine('');
      this.emitLine('// Initialize logic engine');
      this.emitLine('const __logicEngine = new LogicEngine();');
      this.emitLine('');
    }

    // ترجمة جسم البرنامج
    for (const statement of program.body) {
      this.compileStatement(statement);
    }

    return this.output;
  }

  // ============================================================================
  // ترجمة العبارات
  // ============================================================================

  private compileStatement(stmt: AST.Statement): void {
    switch (stmt.type) {
      case 'ExpressionStatement':
        this.compileExpressionStatement(stmt as AST.ExpressionStatement);
        break;
      case 'VariableDeclaration':
        this.compileVariableDeclaration(stmt as AST.VariableDeclaration);
        break;
      case 'FunctionDeclaration':
        this.compileFunctionDeclaration(stmt as AST.FunctionDeclaration);
        break;
      case 'ClassDeclaration':
        this.compileClassDeclaration(stmt as AST.ClassDeclaration);
        break;
      case 'IfStatement':
        this.compileIfStatement(stmt as AST.IfStatement);
        break;
      case 'WhileStatement':
        this.compileWhileStatement(stmt as AST.WhileStatement);
        break;
      case 'ForStatement':
        this.compileForStatement(stmt as AST.ForStatement);
        break;
      case 'ReturnStatement':
        this.compileReturnStatement(stmt as AST.ReturnStatement);
        break;
      case 'BlockStatement':
        this.compileBlockStatement(stmt as AST.BlockStatement);
        break;
      case 'TryStatement':
        this.compileTryStatement(stmt as AST.TryStatement);
        break;
      case 'ThrowStatement':
        this.compileThrowStatement(stmt as AST.ThrowStatement);
        break;
      case 'BreakStatement':
        this.emitLine('break;');
        break;
      case 'ContinueStatement':
        this.emitLine('continue;');
        break;
      case 'HybridBlock':
        this.compileHybridBlock(stmt as AST.HybridBlock);
        break;
      case 'FactDeclaration':
        this.compileFactDeclaration(stmt as AST.FactDeclaration);
        break;
      case 'RuleDeclaration':
        this.compileRuleDeclaration(stmt as AST.RuleDeclaration);
        break;
      case 'ImportDeclaration':
        this.compileImportDeclaration(stmt as AST.ImportDeclaration);
        break;
      case 'ExportDeclaration':
        this.compileExportDeclaration(stmt as AST.ExportDeclaration);
        break;
      default:
        throw new Error(`Unsupported statement type: ${stmt.type}`);
    }
  }

  private compileExpressionStatement(stmt: AST.ExpressionStatement): void {
    const expr = this.compileExpression(stmt.expression);
    this.emitLine(`${expr};`);
  }

  private compileVariableDeclaration(stmt: AST.VariableDeclaration): void {
    // تحويل الكلمات المفتاحية العربية إلى الإنجليزية
    const kind = stmt.kind === 'ثابت' ? 'const' :
                 stmt.kind === 'متغير' ? 'var' : 'let';

    for (const declarator of stmt.declarations) {
      const name = declarator.id.name;
      const init = declarator.init ? this.compileExpression(declarator.init) : 'undefined';
      this.emitLine(`${kind} ${name} = ${init};`);
    }
  }

  private compileFunctionDeclaration(stmt: AST.FunctionDeclaration): void {
    const async = stmt.isAsync ? 'async ' : '';
    const name = stmt.name.name;
    const params = stmt.parameters.map(p => {
      if (p.isRest) return `...${p.name.name}`;
      if (p.defaultValue) {
        return `${p.name.name} = ${this.compileExpression(p.defaultValue)}`;
      }
      return p.name.name;
    }).join(', ');

    this.emit(`${async}function ${name}(${params}) `);
    this.compileBlockStatement(stmt.body, false);
    this.emitLine('');
  }

  private compileClassDeclaration(stmt: AST.ClassDeclaration): void {
    const name = stmt.name.name;
    const extend = stmt.superClass ? ` extends ${stmt.superClass.name}` : '';

    this.emitLine(`class ${name}${extend} {`);
    this.indentLevel++;

    for (const member of stmt.body.body) {
      if (member.type === 'MethodDefinition') {
        this.compileMethodDefinition(member as AST.MethodDefinition);
      } else if (member.type === 'PropertyDefinition') {
        this.compilePropertyDefinition(member as AST.PropertyDefinition);
      }
    }

    this.indentLevel--;
    this.emitLine('}');
    this.emitLine('');
  }

  private compileMethodDefinition(method: AST.MethodDefinition): void {
    const static_ = method.isStatic ? 'static ' : '';
    const async = method.isAsync ? 'async ' : '';
    const name = method.key.name;
    const params = method.parameters.map(p => p.name.name).join(', ');

    this.emit(`${static_}${async}${name}(${params}) `);
    this.compileBlockStatement(method.body, false);
    this.emitLine('');
  }

  private compilePropertyDefinition(prop: AST.PropertyDefinition): void {
    const static_ = prop.isStatic ? 'static ' : '';
    const name = prop.key.name;
    const value = prop.value ? this.compileExpression(prop.value) : 'undefined';
    this.emitLine(`${static_}${name} = ${value};`);
  }

  private compileIfStatement(stmt: AST.IfStatement): void {
    const test = this.compileExpression(stmt.test);
    this.emit(`if (${test}) `);
    this.compileBlockStatement(stmt.consequent, false);

    if (stmt.alternate) {
      if (stmt.alternate.type === 'IfStatement') {
        this.emit(' else ');
        this.compileIfStatement(stmt.alternate as AST.IfStatement);
      } else {
        this.emit(' else ');
        this.compileBlockStatement(stmt.alternate as AST.BlockStatement, false);
        this.emitLine('');
      }
    } else {
      this.emitLine('');
    }
  }

  private compileWhileStatement(stmt: AST.WhileStatement): void {
    const test = this.compileExpression(stmt.test);
    this.emit(`while (${test}) `);
    this.compileBlockStatement(stmt.body, false);
    this.emitLine('');
  }

  private compileForStatement(stmt: AST.ForStatement): void {
    let init = '';
    if (stmt.init) {
      if (stmt.init.type === 'VariableDeclaration') {
        const decl = stmt.init as AST.VariableDeclaration;
        const declarator = decl.declarations[0];
        const name = declarator.id.name;
        const value = declarator.init ? this.compileExpression(declarator.init) : 'undefined';
        // تحويل الكلمات المفتاحية العربية إلى الإنجليزية
        const kind = decl.kind === 'ثابت' ? 'const' :
                     decl.kind === 'متغير' ? 'var' : 'let';
        init = `${kind} ${name} = ${value}`;
      } else {
        init = this.compileExpression(stmt.init as AST.Expression);
      }
    }

    const test = stmt.test ? this.compileExpression(stmt.test) : '';
    const update = stmt.update ? this.compileExpression(stmt.update) : '';

    this.emit(`for (${init}; ${test}; ${update}) `);
    this.compileBlockStatement(stmt.body, false);
    this.emitLine('');
  }

  private compileReturnStatement(stmt: AST.ReturnStatement): void {
    if (stmt.argument) {
      const arg = this.compileExpression(stmt.argument);
      this.emitLine(`return ${arg};`);
    } else {
      this.emitLine('return;');
    }
  }

  private compileBlockStatement(stmt: AST.BlockStatement, standalone: boolean = true): void {
    if (standalone) {
      this.emitLine('{');
    } else {
      this.emit('{');
      this.output += '\n';
    }

    this.indentLevel++;
    for (const statement of stmt.body) {
      this.compileStatement(statement);
    }
    this.indentLevel--;

    this.emitLine('}');
  }

  private compileTryStatement(stmt: AST.TryStatement): void {
    this.emit('try ');
    this.compileBlockStatement(stmt.block, false);

    if (stmt.handler) {
      const param = stmt.handler.param ? stmt.handler.param.name : 'error';
      this.emit(` catch (${param}) `);
      this.compileBlockStatement(stmt.handler.body, false);
    }

    if (stmt.finalizer) {
      this.emit(' finally ');
      this.compileBlockStatement(stmt.finalizer, false);
    }

    this.emitLine('');
  }

  private compileThrowStatement(stmt: AST.ThrowStatement): void {
    const arg = this.compileExpression(stmt.argument);
    this.emitLine(`throw ${arg};`);
  }

  private compileImportDeclaration(stmt: AST.ImportDeclaration): void {
    if (this.options.module === 'esm') {
      const specifiers = stmt.specifiers.map(s => {
        if (s.local) {
          return `${s.imported.name} as ${s.local.name}`;
        }
        return s.imported.name;
      }).join(', ');
      
      this.emitLine(`import { ${specifiers} } from ${this.compileExpression(stmt.source)};`);
    } else {
      // CommonJS
      for (const spec of stmt.specifiers) {
        const local = spec.local ? spec.local.name : spec.imported.name;
        this.emitLine(`const ${local} = require(${this.compileExpression(stmt.source)}).${spec.imported.name};`);
      }
    }
  }

  private compileExportDeclaration(stmt: AST.ExportDeclaration): void {
    if (this.options.module === 'esm') {
      if (stmt.isDefault && stmt.declaration) {
        this.emit('export default ');
        this.compileStatement(stmt.declaration);
      } else if (stmt.declaration) {
        this.emit('export ');
        this.compileStatement(stmt.declaration);
      } else {
        const specifiers = stmt.specifiers.map(s => {
          if (s.exported) {
            return `${s.local.name} as ${s.exported.name}`;
          }
          return s.local.name;
        }).join(', ');
        
        this.emitLine(`export { ${specifiers} };`);
      }
    } else {
      // CommonJS
      if (stmt.declaration) {
        this.compileStatement(stmt.declaration);
        // Extract name from declaration and export it
      }
    }
  }

  private compileHybridBlock(stmt: AST.HybridBlock): void {
    this.emitLine('// Hybrid block');
    for (const statement of stmt.body) {
      this.compileStatement(statement);
    }
  }

  private compileFactDeclaration(stmt: AST.FactDeclaration): void {
    const args = stmt.args.map((arg: AST.Expression) => {
      const value = this.compileExpression(arg);
      return `new Term(${value}, false)`;
    }).join(', ');

    this.emitLine(`__logicEngine.addFact(new Fact(new Predicate("${stmt.predicate}", [${args}])));`);
  }

  private compileRuleDeclaration(stmt: AST.RuleDeclaration): void {
    const headArgs = stmt.head.args.map((arg: AST.Expression) => {
      const value = this.compileExpression(arg);
      // Check if it's a variable (starts with ?)
      if (value.startsWith('"?') || value.startsWith("'?")) {
        const varName = value.slice(2, -1);
        return `new Term("${varName}", true)`;
      }
      return `new Term(${value}, false)`;
    }).join(', ');

    const bodyPredicates = stmt.body.map(bodyFact => {
      const bodyArgs = bodyFact.args.map((arg: AST.Expression) => {
        const value = this.compileExpression(arg);
        if (value.startsWith('"?') || value.startsWith("'?")) {
          const varName = value.slice(2, -1);
          return `new Term("${varName}", true)`;
        }
        return `new Term(${value}, false)`;
      }).join(', ');
      return `new Predicate("${bodyFact.predicate}", [${bodyArgs}])`;
    }).join(', ');

    this.emitLine(`__logicEngine.addRule(new Rule(new Predicate("${stmt.head.predicate}", [${headArgs}]), [${bodyPredicates}]));`);
  }

  // ============================================================================
  // ترجمة التعبيرات
  // ============================================================================

  private compileExpression(expr: AST.Expression): string {
    switch (expr.type) {
      case 'Identifier':
        return (expr as AST.Identifier).name;

      case 'Literal':
        return this.compileLiteral(expr as AST.Literal);

      case 'BinaryExpression':
        return this.compileBinaryExpression(expr as AST.BinaryExpression);

      case 'UnaryExpression':
        return this.compileUnaryExpression(expr as AST.UnaryExpression);

      case 'LogicalExpression':
        return this.compileLogicalExpression(expr as AST.LogicalExpression);

      case 'CallExpression':
        return this.compileCallExpression(expr as AST.CallExpression);

      case 'MemberExpression':
        return this.compileMemberExpression(expr as AST.MemberExpression);

      case 'AssignmentExpression':
        return this.compileAssignmentExpression(expr as AST.AssignmentExpression);

      case 'ConditionalExpression':
        return this.compileConditionalExpression(expr as AST.ConditionalExpression);

      case 'ArrayExpression':
        return this.compileArrayExpression(expr as AST.ArrayExpression);

      case 'ObjectExpression':
        return this.compileObjectExpression(expr as AST.ObjectExpression);

      case 'FunctionExpression':
        return this.compileFunctionExpression(expr as AST.FunctionExpression);

      case 'ArrowFunctionExpression':
        return this.compileArrowFunctionExpression(expr as AST.ArrowFunctionExpression);

      case 'ThisExpression':
        return 'this';

      case 'SuperExpression':
        return 'super';

      case 'NewExpression':
        return this.compileNewExpression(expr as AST.NewExpression);

      case 'AwaitExpression':
        return `await ${this.compileExpression((expr as AST.AwaitExpression).argument)}`;

      case 'SpreadExpression':
        return `...${this.compileExpression((expr as AST.SpreadExpression).argument)}`;

      case 'QueryExpression':
        return this.compileQueryExpression(expr as AST.QueryExpression);

      case 'NegationExpression':
        return this.compileNegationExpression(expr as AST.NegationExpression);

      case 'CutExpression':
        return this.compileCutExpression(expr as AST.CutExpression);

      case 'FindAllExpression':
        return this.compileFindAllExpression(expr as AST.FindAllExpression);

      case 'BagOfExpression':
        return this.compileBagOfExpression(expr as AST.BagOfExpression);

      case 'SetOfExpression':
        return this.compileSetOfExpression(expr as AST.SetOfExpression);

      case 'AssertExpression':
        return this.compileAssertExpression(expr as AST.AssertExpression);

      case 'RetractExpression':
        return this.compileRetractExpression(expr as AST.RetractExpression);

      case 'IsExpression':
        return this.compileIsExpression(expr as AST.IsExpression);

      default:
        throw new Error(`Unsupported expression type: ${expr.type}`);
    }
  }

  private compileLiteral(expr: AST.Literal): string {
    if (typeof expr.value === 'string') {
      return `"${expr.value.replace(/"/g, '\\"')}"`;
    } else if (typeof expr.value === 'boolean') {
      return expr.value ? 'true' : 'false';
    } else if (expr.value === null) {
      return 'null';
    } else if (expr.value === undefined) {
      return 'undefined';
    }
    return String(expr.value);
  }

  private compileBinaryExpression(expr: AST.BinaryExpression): string {
    const left = this.compileExpression(expr.left);
    const right = this.compileExpression(expr.right);
    return `(${left} ${expr.operator} ${right})`;
  }

  private compileUnaryExpression(expr: AST.UnaryExpression): string {
    const arg = this.compileExpression(expr.argument);

    // Handle Arabic operators
    if (expr.operator === 'ليس') {
      return `(!${arg})`;
    } else if (expr.operator === 'نوع') {
      return `typeof ${arg}`;
    }

    return expr.prefix ? `(${expr.operator}${arg})` : `(${arg}${expr.operator})`;
  }

  private compileLogicalExpression(expr: AST.LogicalExpression): string {
    const left = this.compileExpression(expr.left);
    const right = this.compileExpression(expr.right);

    // Convert Arabic operators
    let op = expr.operator;
    if (op === 'و') op = '&&';
    if (op === 'أو') op = '||';

    return `(${left} ${op} ${right})`;
  }

  private compileCallExpression(expr: AST.CallExpression): string {
    const callee = this.compileExpression(expr.callee);
    const args = expr.args.map((arg: AST.Expression) => this.compileExpression(arg)).join(', ');

    // Handle built-in functions
    if (callee === 'اطبع') {
      return `console.log(${args})`;
    } else if (callee === 'طول') {
      return `(${args}).length`;
    } else if (callee === 'استعلام') {
      return this.compileQueryCall(expr.args);
    }

    return `${callee}(${args})`;
  }

  private compileMemberExpression(expr: AST.MemberExpression): string {
    const object = this.compileExpression(expr.object);

    if (expr.computed) {
      const property = this.compileExpression(expr.property);
      return `${object}[${property}]`;
    } else {
      const property = (expr.property as AST.Identifier).name;
      return `${object}.${property}`;
    }
  }

  private compileAssignmentExpression(expr: AST.AssignmentExpression): string {
    const left = this.compileExpression(expr.left);
    const right = this.compileExpression(expr.right);
    return `${left} ${expr.operator} ${right}`;
  }

  private compileConditionalExpression(expr: AST.ConditionalExpression): string {
    const test = this.compileExpression(expr.test);
    const consequent = this.compileExpression(expr.consequent);
    const alternate = this.compileExpression(expr.alternate);
    return `(${test} ? ${consequent} : ${alternate})`;
  }

  private compileArrayExpression(expr: AST.ArrayExpression): string {
    const elements = expr.elements.map(el =>
      el ? this.compileExpression(el) : ''
    ).join(', ');
    return `[${elements}]`;
  }

  private compileObjectExpression(expr: AST.ObjectExpression): string {
    const properties = expr.properties.map(prop => {
      const key = prop.key.type === 'Identifier'
        ? (prop.key as AST.Identifier).name
        : this.compileLiteral(prop.key as AST.Literal);
      const value = this.compileExpression(prop.value);

      if (prop.shorthand) {
        return key;
      }

      if (prop.computed) {
        return `[${key}]: ${value}`;
      }

      return `${key}: ${value}`;
    }).join(', ');

    return `{${properties}}`;
  }

  private compileFunctionExpression(expr: AST.FunctionExpression): string {
    const async = expr.isAsync ? 'async ' : '';
    const name = expr.name ? expr.name.name : '';
    const params = expr.parameters.map(p => p.name.name).join(', ');

    // We need to compile the body inline
    const bodyStatements = expr.body.body.map(stmt => {
      const oldOutput = this.output;
      this.output = '';
      this.compileStatement(stmt);
      const result = this.output.trim();
      this.output = oldOutput;
      return result;
    }).join(' ');

    return `${async}function ${name}(${params}) { ${bodyStatements} }`;
  }

  private compileArrowFunctionExpression(expr: AST.ArrowFunctionExpression): string {
    const async = expr.isAsync ? 'async ' : '';
    const params = expr.parameters.map(p => p.name.name).join(', ');

    if (expr.body.type === 'BlockStatement') {
      const bodyStatements = (expr.body as AST.BlockStatement).body.map(stmt => {
        const oldOutput = this.output;
        this.output = '';
        this.compileStatement(stmt);
        const result = this.output.trim();
        this.output = oldOutput;
        return result;
      }).join(' ');

      return `${async}(${params}) => { ${bodyStatements} }`;
    } else {
      const body = this.compileExpression(expr.body as AST.Expression);
      return `${async}(${params}) => ${body}`;
    }
  }

  private compileNewExpression(expr: AST.NewExpression): string {
    const callee = this.compileExpression(expr.callee);
    const args = expr.args.map((arg: AST.Expression) => this.compileExpression(arg)).join(', ');
    return `new ${callee}(${args})`;
  }

  private compileQueryExpression(expr: AST.QueryExpression): string {
    const args = expr.goal.args.map((arg: AST.Expression) => {
      const value = this.compileExpression(arg);
      if (value.startsWith('"?') || value.startsWith("'?")) {
        const varName = value.slice(2, -1);
        return `new Term("${varName}", true)`;
      }
      return `new Term(${value}, false)`;
    }).join(', ');

    return `__logicEngine.query(new Predicate("${expr.goal.predicate}", [${args}])).map(s => s.toObject())`;
  }

  private compileQueryCall(args: AST.Expression[]): string {
    if (args.length === 0) {
      throw new Error('Query requires at least one argument');
    }

    // This is a simplified version
    return `__logicEngine.query(${this.compileExpression(args[0])})`;
  }

  // ============================================================================
  // ترجمة التعبيرات المنطقية المتقدمة
  // ============================================================================

  /**
   * ترجمة النفي كفشل
   */
  private compileNegationExpression(expr: AST.NegationExpression): string {
    const goal = this.compileQueryExpression(expr.goal);
    return `__logicEngine.negationAsFailure(${goal})`;
  }

  /**
   * ترجمة عامل القطع
   */
  private compileCutExpression(_expr: AST.CutExpression): string {
    return `(() => { __logicEngine.cutEncountered = true; return true; })()`;
  }

  /**
   * ترجمة FindAll
   */
  private compileFindAllExpression(expr: AST.FindAllExpression): string {
    const template = this.compileExpression(expr.template);

    // تحويل القالب إلى Term
    let templateTerm: string;
    if (template.startsWith('"?') || template.startsWith("'?")) {
      const varName = template.slice(2, -1);
      templateTerm = `new Term("${varName}", true)`;
    } else {
      templateTerm = `new Term(${template}, false)`;
    }

    // تحليل الهدف
    const goalArgs = expr.goal.goal.args.map((arg: AST.Expression) => {
      const value = this.compileExpression(arg);
      if (value.startsWith('"?') || value.startsWith("'?")) {
        const varName = value.slice(2, -1);
        return `new Term("${varName}", true)`;
      }
      return `new Term(${value}, false)`;
    }).join(', ');

    const goalPredicate = `new Predicate("${expr.goal.goal.predicate}", [${goalArgs}])`;

    return `__logicEngine.findAll(${templateTerm}, ${goalPredicate})`;
  }

  /**
   * ترجمة BagOf
   */
  private compileBagOfExpression(expr: AST.BagOfExpression): string {
    const template = this.compileExpression(expr.template);

    let templateTerm: string;
    if (template.startsWith('"?') || template.startsWith("'?")) {
      const varName = template.slice(2, -1);
      templateTerm = `new Term("${varName}", true)`;
    } else {
      templateTerm = `new Term(${template}, false)`;
    }

    const goalArgs = expr.goal.goal.args.map((arg: AST.Expression) => {
      const value = this.compileExpression(arg);
      if (value.startsWith('"?') || value.startsWith("'?")) {
        const varName = value.slice(2, -1);
        return `new Term("${varName}", true)`;
      }
      return `new Term(${value}, false)`;
    }).join(', ');

    const goalPredicate = `new Predicate("${expr.goal.goal.predicate}", [${goalArgs}])`;

    return `__logicEngine.bagOf(${templateTerm}, ${goalPredicate})`;
  }

  /**
   * ترجمة SetOf
   */
  private compileSetOfExpression(expr: AST.SetOfExpression): string {
    const template = this.compileExpression(expr.template);

    let templateTerm: string;
    if (template.startsWith('"?') || template.startsWith("'?")) {
      const varName = template.slice(2, -1);
      templateTerm = `new Term("${varName}", true)`;
    } else {
      templateTerm = `new Term(${template}, false)`;
    }

    const goalArgs = expr.goal.goal.args.map((arg: AST.Expression) => {
      const value = this.compileExpression(arg);
      if (value.startsWith('"?') || value.startsWith("'?")) {
        const varName = value.slice(2, -1);
        return `new Term("${varName}", true)`;
      }
      return `new Term(${value}, false)`;
    }).join(', ');

    const goalPredicate = `new Predicate("${expr.goal.goal.predicate}", [${goalArgs}])`;

    return `__logicEngine.setOf(${templateTerm}, ${goalPredicate})`;
  }

  /**
   * ترجمة Assert
   */
  private compileAssertExpression(expr: AST.AssertExpression): string {
    // التحقق من نوع الحقيقة
    if (expr.fact.type === 'FactDeclaration') {
      const fact = expr.fact as AST.FactDeclaration;
      const args = fact.args.map((arg: AST.Expression) => {
        const value = this.compileExpression(arg);
        if (value.startsWith('"?') || value.startsWith("'?")) {
          const varName = value.slice(2, -1);
          return `new Term("${varName}", true)`;
        }
        return `new Term(${value}, false)`;
      }).join(', ');

      const predicate = `new Predicate("${fact.predicate}", [${args}])`;
      return `__logicEngine.assertFact(${predicate})`;
    }
    return `__logicEngine.assertFact(new Predicate("unknown", []))`;
  }

  /**
   * ترجمة Retract
   */
  private compileRetractExpression(expr: AST.RetractExpression): string {
    // التحقق من نوع الحقيقة
    if (expr.fact.type === 'FactDeclaration') {
      const fact = expr.fact as AST.FactDeclaration;
      const args = fact.args.map((arg: AST.Expression) => {
        const value = this.compileExpression(arg);
        if (value.startsWith('"?') || value.startsWith("'?")) {
          const varName = value.slice(2, -1);
          return `new Term("${varName}", true)`;
        }
        return `new Term(${value}, false)`;
      }).join(', ');

      const predicate = `new Predicate("${fact.predicate}", [${args}])`;
      return `__logicEngine.retractFact(${predicate})`;
    }
    return `__logicEngine.retractFact(new Predicate("unknown", []))`;
  }

  /**
   * ترجمة Is
   */
  private compileIsExpression(expr: AST.IsExpression): string {
    const variable = expr.variable.name;
    const expression = this.compileExpression(expr.expression);

    return `(() => {
      const result = new Term("${variable}", true);
      const sub = __logicEngine.evaluateArithmetic(result, ${expression}, new Substitution());
      return sub ? sub.get("${variable}") : undefined;
    })()`;
  }

  // ============================================================================
  // دوال مساعدة
  // ============================================================================

  private emit(code: string): void {
    this.output += code;
  }

  private emitLine(code: string): void {
    this.output += this.getIndent() + code + '\n';
  }

  private getIndent(): string {
    return '  '.repeat(this.indentLevel);
  }
}
